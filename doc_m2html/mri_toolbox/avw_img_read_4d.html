<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of avw_img_read_4d</title>
  <meta name="keywords" content="avw_img_read_4d">
  <meta name="description" content="avw_img_read - read Analyze format data image (*.img)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">mri_toolbox</a> &gt; avw_img_read_4d.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for mri_toolbox&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>avw_img_read_4d
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>avw_img_read - read Analyze format data image (*.img)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [ avw, machine ] = avw_img_read_4d(fileprefix,volIndex,IMGorient,machine) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> avw_img_read - read Analyze format data image (*.img)
 
 [ avw, machine ] = avw_img_read(fileprefix, [volIndex], [orient], [machine])
 
 fileprefix - a string, the filename without the .img extension
 
 volIndex - the volume to read from a 4D file, where the first volume
            has index 1 (the default)
 
 orient - read a specified orientation, integer values:
 
          '', use header history orient field
          0,  transverse unflipped (LAS*)
          1,  coronal unflipped (LA*S)
          2,  sagittal unflipped (L*AS)
          3,  transverse flipped (LPS*)
          4,  coronal flipped (LA*I)
          5,  sagittal flipped (L*AI)
 
 where * follows the slice dimension and letters indicate +XYZ
 orientations (L left, R right, A anterior, P posterior,
 I inferior, &amp; S superior).
 
 Some files may contain data in the 3-5 orientations, but this
 is unlikely. For more information about orientation, see the
 documentation at the end of this .m file.  See also the
 <a href="avw_flip.html" class="code" title="function [ avw ] = avw_flip(avw,dims)">AVW_FLIP</a> function for orthogonal reorientation.

 machine - a string, see machineformat in fread for details.
           The default here is 'ieee-le' but the routine
           will automatically switch between little and big
           endian to read any such Analyze header.  It
           reports the appropriate machine format and can
           return the machine value.

 Returned values:

 avw.hdr - a struct with image data parameters.
 avw.img - a 3D matrix of image data (double precision)
           from a volume of a 4D Analyze file

 The returned 3D matrix will correspond with the
 default ANALYZE coordinate system, which
 is Left-handed:

 X-Y plane is Transverse
 X-Z plane is Coronal
 Y-Z plane is Sagittal

 X axis runs from patient right (low X) to patient Left (high X)
 Y axis runs from posterior (low Y) to Anterior (high Y)
 Z axis runs from inferior (low Z) to Superior (high Z)

 See also: <a href="avw_hdr_read.html" class="code" title="function [ avw, machine ] = avw_hdr_read(fileprefix, machine)">avw_hdr_read</a> (called by this function),
           <a href="avw_view.html" class="code" title="function [ varargout ] = avw_view(avw,parent,command),">avw_view</a>, <a href="avw_write.html" class="code" title="function avw_write(avw, fileprefix, IMGorient, machine)">avw_write</a>, <a href="avw_img_write.html" class="code" title="function avw_img_write(avw, fileprefix, IMGorient, machine)">avw_img_write</a>, <a href="avw_flip.html" class="code" title="function [ avw ] = avw_flip(avw,dims)">avw_flip</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="avw_hdr_read.html" class="code" title="function [ avw, machine ] = avw_hdr_read(fileprefix, machine)">avw_hdr_read</a>	avw_hdr_read - read Analyze format data header (*.hdr)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [ avw ] = read_image(avw,volIndex,IMGorient,machine)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [ avw, machine ] = avw_img_read_4d(fileprefix,volIndex,IMGorient,machine)</a>
0002 
0003 <span class="comment">% avw_img_read - read Analyze format data image (*.img)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% [ avw, machine ] = avw_img_read(fileprefix, [volIndex], [orient], [machine])</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% fileprefix - a string, the filename without the .img extension</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% volIndex - the volume to read from a 4D file, where the first volume</span>
0010 <span class="comment">%            has index 1 (the default)</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% orient - read a specified orientation, integer values:</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%          '', use header history orient field</span>
0015 <span class="comment">%          0,  transverse unflipped (LAS*)</span>
0016 <span class="comment">%          1,  coronal unflipped (LA*S)</span>
0017 <span class="comment">%          2,  sagittal unflipped (L*AS)</span>
0018 <span class="comment">%          3,  transverse flipped (LPS*)</span>
0019 <span class="comment">%          4,  coronal flipped (LA*I)</span>
0020 <span class="comment">%          5,  sagittal flipped (L*AI)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% where * follows the slice dimension and letters indicate +XYZ</span>
0023 <span class="comment">% orientations (L left, R right, A anterior, P posterior,</span>
0024 <span class="comment">% I inferior, &amp; S superior).</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% Some files may contain data in the 3-5 orientations, but this</span>
0027 <span class="comment">% is unlikely. For more information about orientation, see the</span>
0028 <span class="comment">% documentation at the end of this .m file.  See also the</span>
0029 <span class="comment">% AVW_FLIP function for orthogonal reorientation.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% machine - a string, see machineformat in fread for details.</span>
0032 <span class="comment">%           The default here is 'ieee-le' but the routine</span>
0033 <span class="comment">%           will automatically switch between little and big</span>
0034 <span class="comment">%           endian to read any such Analyze header.  It</span>
0035 <span class="comment">%           reports the appropriate machine format and can</span>
0036 <span class="comment">%           return the machine value.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% Returned values:</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% avw.hdr - a struct with image data parameters.</span>
0041 <span class="comment">% avw.img - a 3D matrix of image data (double precision)</span>
0042 <span class="comment">%           from a volume of a 4D Analyze file</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% The returned 3D matrix will correspond with the</span>
0045 <span class="comment">% default ANALYZE coordinate system, which</span>
0046 <span class="comment">% is Left-handed:</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% X-Y plane is Transverse</span>
0049 <span class="comment">% X-Z plane is Coronal</span>
0050 <span class="comment">% Y-Z plane is Sagittal</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% X axis runs from patient right (low X) to patient Left (high X)</span>
0053 <span class="comment">% Y axis runs from posterior (low Y) to Anterior (high Y)</span>
0054 <span class="comment">% Z axis runs from inferior (low Z) to Superior (high Z)</span>
0055 <span class="comment">%</span>
0056 <span class="comment">% See also: avw_hdr_read (called by this function),</span>
0057 <span class="comment">%           avw_view, avw_write, avw_img_write, avw_flip</span>
0058 <span class="comment">%</span>
0059 
0060 
0061 <span class="comment">% $Revision: 1.1 $ $Date: 2004/04/08 20:12:52 $</span>
0062 
0063 <span class="comment">% Licence:  GNU GPL, no express or implied warranties</span>
0064 <span class="comment">% History:  05/2002, Darren.Weber@flinders.edu.au</span>
0065 <span class="comment">%                    The Analyze format is copyright</span>
0066 <span class="comment">%                    (c) Copyright, 1986-1995</span>
0067 <span class="comment">%                    Biomedical Imaging Resource, Mayo Foundation</span>
0068 <span class="comment">%           01/2003, Darren.Weber@flinders.edu.au</span>
0069 <span class="comment">%                    - adapted for matlab v5</span>
0070 <span class="comment">%                    - revised all orientation information and handling</span>
0071 <span class="comment">%                      after seeking further advice from AnalyzeDirect.com</span>
0072 <span class="comment">%           03/2003, Darren.Weber@flinders.edu.au</span>
0073 <span class="comment">%                    - adapted for -ve pixdim values (non standard Analyze)</span>
0074 <span class="comment">%           11/2003, Darren.Weber_at_radiology.ucsf.edu</span>
0075 <span class="comment">%                    - adapted for 4D Analyze files</span>
0076 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0077 
0078 
0079 error(<span class="string">'in development'</span>);
0080 
0081 
0082 <span class="keyword">if</span> ~exist(<span class="string">'fileprefix'</span>,<span class="string">'var'</span>),
0083     msg = sprintf(<span class="string">'...no input fileprefix - see help avw_img_read\n\n'</span>);
0084     error(msg);
0085 <span class="keyword">end</span>
0086 <span class="keyword">if</span> ~exist(<span class="string">'volIndex'</span>,<span class="string">'var'</span>), volIndex = 1; <span class="keyword">end</span>
0087 <span class="keyword">if</span> ~exist(<span class="string">'IMGorient'</span>,<span class="string">'var'</span>), IMGorient = <span class="string">''</span>; <span class="keyword">end</span>
0088 <span class="keyword">if</span> ~exist(<span class="string">'machine'</span>,<span class="string">'var'</span>), machine = <span class="string">'ieee-le'</span>; <span class="keyword">end</span>
0089 
0090 <span class="keyword">if</span> findstr(<span class="string">'.hdr'</span>,fileprefix),
0091     fileprefix = strrep(fileprefix,<span class="string">'.hdr'</span>,<span class="string">''</span>);
0092 <span class="keyword">end</span>
0093 <span class="keyword">if</span> findstr(<span class="string">'.img'</span>,fileprefix),
0094     fileprefix = strrep(fileprefix,<span class="string">'.img'</span>,<span class="string">''</span>);
0095 <span class="keyword">end</span>
0096 
0097 <span class="comment">% MAIN</span>
0098 
0099 <span class="comment">% Read the file header</span>
0100 [ avw, machine ] = <a href="avw_hdr_read.html" class="code" title="function [ avw, machine ] = avw_hdr_read(fileprefix, machine)">avw_hdr_read</a>(fileprefix,machine);
0101 
0102 avw = <a href="#_sub1" class="code" title="subfunction [ avw ] = read_image(avw,volIndex,IMGorient,machine)">read_image</a>(avw,volIndex,IMGorient,machine);
0103 
0104 <span class="keyword">return</span>
0105 
0106 
0107 
0108 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0109 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0110 <a name="_sub1" href="#_subfunctions" class="code">function [ avw ] = read_image(avw,volIndex,IMGorient,machine)</a>
0111 
0112 fid = fopen(sprintf(<span class="string">'%s.img'</span>,avw.fileprefix),<span class="string">'r'</span>,machine);
0113 <span class="keyword">if</span> fid &lt; 0,
0114   msg = sprintf(<span class="string">'...cannot open file %s.img\n\n'</span>,avw.fileprefix);
0115   error(msg);
0116 <span class="keyword">end</span>
0117 
0118 version = <span class="string">'[$Revision: 1.1 $]'</span>;
0119 fprintf(<span class="string">'\nAVW_IMG_READ [v%s]\n'</span>,version(12:16));  tic;
0120 
0121 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0122 <span class="comment">% check data precision</span>
0123 
0124 <span class="comment">% short int bitpix;    /* Number of bits per pixel; 1, 8, 16, 32, or 64. */</span>
0125 <span class="comment">% short int datatype      /* Datatype for this image set */</span>
0126 <span class="comment">% /*Acceptable values for datatype are*/</span>
0127 <span class="comment">% #define DT_NONE             0</span>
0128 <span class="comment">% #define DT_UNKNOWN          0    /*Unknown data type*/</span>
0129 <span class="comment">% #define DT_BINARY           1    /*Binary             ( 1 bit per voxel)*/</span>
0130 <span class="comment">% #define DT_UNSIGNED_CHAR    2    /*Unsigned character ( 8 bits per voxel)*/</span>
0131 <span class="comment">% #define DT_SIGNED_SHORT     4    /*Signed short       (16 bits per voxel)*/</span>
0132 <span class="comment">% #define DT_SIGNED_INT       8    /*Signed integer     (32 bits per voxel)*/</span>
0133 <span class="comment">% #define DT_FLOAT           16    /*Floating point     (32 bits per voxel)*/</span>
0134 <span class="comment">% #define DT_COMPLEX         32    /*Complex (64 bits per voxel; 2 floating point numbers)/*</span>
0135 <span class="comment">% #define DT_DOUBLE          64    /*Double precision   (64 bits per voxel)*/</span>
0136 <span class="comment">% #define DT_RGB            128    /*A Red-Green-Blue datatype*/</span>
0137 <span class="comment">% #define DT_ALL            255    /*Undocumented*/</span>
0138 
0139 <span class="keyword">switch</span> double(avw.hdr.dime.bitpix),
0140   <span class="keyword">case</span>  1,   precision = <span class="string">'bit1'</span>;
0141   <span class="keyword">case</span>  8,   precision = <span class="string">'uchar'</span>;
0142   <span class="keyword">case</span> 16,   precision = <span class="string">'int16'</span>;
0143   <span class="keyword">case</span> 32,
0144     <span class="keyword">if</span>     isequal(avw.hdr.dime.datatype, 8), precision = <span class="string">'int32'</span>;
0145     <span class="keyword">else</span>                                      precision = <span class="string">'single'</span>;
0146     <span class="keyword">end</span>
0147   <span class="keyword">case</span> 64,   precision = <span class="string">'double'</span>;
0148   <span class="keyword">otherwise</span>,
0149     precision = <span class="string">'uchar'</span>;
0150     fprintf(<span class="string">'...precision undefined in header, using ''uchar''\n'</span>);
0151 <span class="keyword">end</span>
0152 
0153 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0154 <span class="comment">% calculate the byte index range for a volume to be read</span>
0155 <span class="comment">% In general, voxel(a,b,c) will be stored as byte N where</span>
0156 <span class="comment">% N = a + Nx(b + Ny*c), given the first voxel of the image</span>
0157 <span class="comment">% is (0,0,0).  Matlab fseek command indexes the first voxel</span>
0158 <span class="comment">% as (0,0,0), so this formula should work.</span>
0159 
0160 Nx = double(avw.hdr.dime.dim(2));
0161 Ny = double(avw.hdr.dime.dim(3));
0162 Nz = double(avw.hdr.dime.dim(4));
0163 Nt = double(avw.hdr.dime.dim(5));
0164 
0165 readPixels = Nx * Ny * Nz;
0166 
0167 bitpix = double(avw.hdr.dime.bitpix);
0168 
0169 <span class="keyword">if</span> Nt == 1,
0170   fprintf(<span class="string">'...reading volume %d of %d\n'</span>,1,Nt);
0171   avw.offset = 0;
0172 <span class="keyword">else</span>
0173   <span class="keyword">if</span> volIndex &lt;= Nt,
0174     fprintf(<span class="string">'...reading volume %d of %d\n'</span>,volIndex,Nt);
0175     avw.offset = (readPixels * volIndex) - readPixels;
0176     <span class="comment">% this the offset in pixels, but we need bytes for fseek!</span>
0177     avw.offset = (avw.offset * bitpix) / 8;
0178     
0179   <span class="keyword">else</span>
0180     msg = sprintf(<span class="string">'volIndex &gt; 4D volume (%d vols)'</span>,Nt);
0181     error(msg);
0182   <span class="keyword">end</span>
0183 <span class="keyword">end</span>
0184 
0185 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0186 <span class="comment">% read a volume from the .img file into matlab</span>
0187 fprintf(<span class="string">'...reading %s Analyze %s image format.\n'</span>,machine,precision);
0188 fseek(fid,avw.offset,<span class="string">'bof'</span>);
0189 <span class="comment">% adjust for matlab version</span>
0190 ver = version;
0191 ver = str2num(ver(1));
0192 <span class="keyword">if</span> ver &lt; 6,
0193   tmp = fread(fid,readPixels,sprintf(<span class="string">'%s'</span>,precision));
0194 <span class="keyword">else</span>,
0195 
0196   ftell(fid)
0197   
0198   
0199   [tmp, count] = fread(fid,readPixels,sprintf(<span class="string">'%s=&gt;double'</span>,precision));
0200   
0201   
0202   ftell(fid)
0203   
0204   avw.offset = (readPixels * [volIndex + 1]) - readPixels;
0205   avw.offset = (avw.offset * bitpix) / 8
0206   
0207   
0208   <span class="keyword">if</span> count ~= readPixels,
0209     msg = sprintf(<span class="string">'only read %d of %d total pixels'</span>,count,readPixels);
0210     error(msg);
0211   <span class="keyword">end</span>
0212 <span class="keyword">end</span>
0213 fclose(fid);
0214 
0215 <span class="comment">% Update the global min and max values</span>
0216 avw.hdr.dime.glmax = max(double(tmp));
0217 avw.hdr.dime.glmin = min(double(tmp));
0218 
0219 
0220 <span class="comment">%---------------------------------------------------------------</span>
0221 <span class="comment">% Now partition the img data into xyz</span>
0222 
0223 <span class="comment">% --- first figure out the size of the image</span>
0224 
0225 <span class="comment">% short int dim[ ];      /* Array of the image dimensions */</span>
0226 <span class="comment">%</span>
0227 <span class="comment">% dim[0]      Number of dimensions in database; usually 4.</span>
0228 <span class="comment">% dim[1]      Image X dimension;  number of pixels in an image row.</span>
0229 <span class="comment">% dim[2]      Image Y dimension;  number of pixel rows in slice.</span>
0230 <span class="comment">% dim[3]      Volume Z dimension; number of slices in a volume.</span>
0231 <span class="comment">% dim[4]      Time points; number of volumes in database.</span>
0232 
0233 PixelDim = double(avw.hdr.dime.dim(2));
0234 RowDim   = double(avw.hdr.dime.dim(3));
0235 SliceDim = double(avw.hdr.dime.dim(4));
0236 
0237 PixelSz  = double(avw.hdr.dime.pixdim(2));
0238 RowSz    = double(avw.hdr.dime.pixdim(3));
0239 SliceSz  = double(avw.hdr.dime.pixdim(4));
0240 
0241 
0242 
0243 
0244 
0245 <span class="comment">% ---- NON STANDARD ANALYZE...</span>
0246 
0247 <span class="comment">% Some Analyze files have been found to set -ve pixdim values, eg</span>
0248 <span class="comment">% the MNI template avg152T1_brain in the FSL etc/standard folder,</span>
0249 <span class="comment">% perhaps to indicate flipped orientation?  If so, this code below</span>
0250 <span class="comment">% will NOT handle the flip correctly!</span>
0251 <span class="keyword">if</span> PixelSz &lt; 0,
0252   warning(<span class="string">'X pixdim &lt; 0 !!! resetting to abs(avw.hdr.dime.pixdim(2))'</span>);
0253   PixelSz = abs(PixelSz);
0254   avw.hdr.dime.pixdim(2) = single(PixelSz);
0255 <span class="keyword">end</span>
0256 <span class="keyword">if</span> RowSz &lt; 0,
0257   warning(<span class="string">'Y pixdim &lt; 0 !!! resetting to abs(avw.hdr.dime.pixdim(3))'</span>);
0258   RowSz = abs(RowSz);
0259   avw.hdr.dime.pixdim(3) = single(RowSz);
0260 <span class="keyword">end</span>
0261 <span class="keyword">if</span> SliceSz &lt; 0,
0262   warning(<span class="string">'Z pixdim &lt; 0 !!! resetting to abs(avw.hdr.dime.pixdim(4))'</span>);
0263   SliceSz = abs(SliceSz);
0264   avw.hdr.dime.pixdim(4) = single(SliceSz);
0265 <span class="keyword">end</span>
0266 
0267 <span class="comment">% ---- END OF NON STANDARD ANALYZE</span>
0268 
0269 
0270 
0271 
0272 
0273 <span class="comment">% --- check the orientation specification and arrange img accordingly</span>
0274 <span class="keyword">if</span> ~isempty(IMGorient),
0275   <span class="keyword">if</span> ischar(IMGorient),
0276     avw.hdr.hist.orient = uint8(str2num(IMGorient));
0277   <span class="keyword">else</span>
0278     avw.hdr.hist.orient = uint8(IMGorient);
0279   <span class="keyword">end</span>
0280 <span class="keyword">end</span>,
0281 
0282 <span class="keyword">if</span> isempty(avw.hdr.hist.orient),
0283   msg = [ <span class="string">'...unspecified avw.hdr.hist.orient, using default 0\n'</span>,<span class="keyword">...</span>
0284       <span class="string">'   (check image and try explicit IMGorient option).\n'</span>];
0285   fprintf(msg);
0286   avw.hdr.hist.orient = uint8(0);
0287 <span class="keyword">end</span>
0288 
0289 <span class="keyword">switch</span> double(avw.hdr.hist.orient),
0290   
0291   <span class="keyword">case</span> 0, <span class="comment">% transverse unflipped</span>
0292     
0293     <span class="comment">% orient = 0:  The primary orientation of the data on disk is in the</span>
0294     <span class="comment">% transverse plane relative to the object scanned.  Most commonly, the fastest</span>
0295     <span class="comment">% moving index through the voxels that are part of this transverse image would</span>
0296     <span class="comment">% span the right-&gt;left extent of the structure imaged, with the next fastest</span>
0297     <span class="comment">% moving index spanning the posterior-&gt;anterior extent of the structure.  This</span>
0298     <span class="comment">% 'orient' flag would indicate to Analyze that this data should be placed in</span>
0299     <span class="comment">% the X-Y plane of the 3D Analyze Coordinate System, with the Z dimension</span>
0300     <span class="comment">% being the slice direction.</span>
0301     
0302     <span class="comment">% For the 'transverse unflipped' type, the voxels are stored with</span>
0303     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to left</span>
0304     <span class="comment">% Rows in   'y' axis                  - from patient posterior to anterior</span>
0305     <span class="comment">% Slices in 'z' axis                  - from patient inferior to superior</span>
0306     
0307     fprintf(<span class="string">'...reading axial unflipped orientation\n'</span>);
0308     
0309     avw.img = zeros(PixelDim,RowDim,SliceDim);
0310     
0311     n = 1;
0312     x = 1:PixelDim;
0313     <span class="keyword">for</span> z = 1:SliceDim,
0314       <span class="keyword">for</span> y = 1:RowDim,
0315         <span class="comment">% load Y row of X values into Z slice avw.img</span>
0316         avw.img(x,y,z) = tmp(n:n+(PixelDim-1));
0317         n = n + PixelDim;
0318       <span class="keyword">end</span>
0319     <span class="keyword">end</span>
0320     
0321     <span class="comment">% no need to rearrange avw.hdr.dime.dim or avw.hdr.dime.pixdim</span>
0322     
0323     
0324   <span class="keyword">case</span> 1, <span class="comment">% coronal unflipped</span>
0325     
0326     <span class="comment">% orient = 1:  The primary orientation of the data on disk is in the coronal</span>
0327     <span class="comment">% plane relative to the object scanned.  Most commonly, the fastest moving</span>
0328     <span class="comment">% index through the voxels that are part of this coronal image would span the</span>
0329     <span class="comment">% right-&gt;left extent of the structure imaged, with the next fastest moving</span>
0330     <span class="comment">% index spanning the inferior-&gt;superior extent of the structure.  This 'orient'</span>
0331     <span class="comment">% flag would indicate to Analyze that this data should be placed in the X-Z</span>
0332     <span class="comment">% plane of the 3D Analyze Coordinate System, with the Y dimension being the</span>
0333     <span class="comment">% slice direction.</span>
0334     
0335     <span class="comment">% For the 'coronal unflipped' type, the voxels are stored with</span>
0336     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to left</span>
0337     <span class="comment">% Rows in   'z' axis                  - from patient inferior to superior</span>
0338     <span class="comment">% Slices in 'y' axis                  - from patient posterior to anterior</span>
0339     
0340     fprintf(<span class="string">'...reading coronal unflipped orientation\n'</span>);
0341     
0342     avw.img = zeros(PixelDim,SliceDim,RowDim);
0343     
0344     n = 1;
0345     x = 1:PixelDim;
0346     <span class="keyword">for</span> y = 1:SliceDim,
0347       <span class="keyword">for</span> z = 1:RowDim,
0348         <span class="comment">% load Z row of X values into Y slice avw.img</span>
0349         avw.img(x,y,z) = tmp(n:n+(PixelDim-1));
0350         n = n + PixelDim;
0351       <span class="keyword">end</span>
0352     <span class="keyword">end</span>
0353     
0354     <span class="comment">% rearrange avw.hdr.dime.dim or avw.hdr.dime.pixdim</span>
0355     avw.hdr.dime.dim(2:4) = int16([PixelDim,SliceDim,RowDim]);
0356     avw.hdr.dime.pixdim(2:4) = single([PixelSz,SliceSz,RowSz]);
0357     
0358     
0359   <span class="keyword">case</span> 2, <span class="comment">% sagittal unflipped</span>
0360     
0361     <span class="comment">% orient = 2:  The primary orientation of the data on disk is in the sagittal</span>
0362     <span class="comment">% plane relative to the object scanned.  Most commonly, the fastest moving</span>
0363     <span class="comment">% index through the voxels that are part of this sagittal image would span the</span>
0364     <span class="comment">% posterior-&gt;anterior extent of the structure imaged, with the next fastest</span>
0365     <span class="comment">% moving index spanning the inferior-&gt;superior extent of the structure.  This</span>
0366     <span class="comment">% 'orient' flag would indicate to Analyze that this data should be placed in</span>
0367     <span class="comment">% the Y-Z plane of the 3D Analyze Coordinate System, with the X dimension</span>
0368     <span class="comment">% being the slice direction.</span>
0369     
0370     <span class="comment">% For the 'sagittal unflipped' type, the voxels are stored with</span>
0371     <span class="comment">% Pixels in 'y' axis (varies fastest) - from patient posterior to anterior</span>
0372     <span class="comment">% Rows in   'z' axis                  - from patient inferior to superior</span>
0373     <span class="comment">% Slices in 'x' axis                  - from patient right to left</span>
0374     
0375     fprintf(<span class="string">'...reading sagittal unflipped orientation\n'</span>);
0376     
0377     avw.img = zeros(SliceDim,PixelDim,RowDim);
0378     
0379     n = 1;
0380     y = 1:PixelDim;         <span class="comment">% posterior to anterior (fastest)</span>
0381     
0382     <span class="keyword">for</span> x = 1:SliceDim,     <span class="comment">% right to left (slowest)</span>
0383       <span class="keyword">for</span> z = 1:RowDim,   <span class="comment">% inferior to superior</span>
0384         
0385         <span class="comment">% load Z row of Y values into X slice avw.img</span>
0386         avw.img(x,y,z) = tmp(n:n+(PixelDim-1));
0387         n = n + PixelDim;
0388       <span class="keyword">end</span>
0389     <span class="keyword">end</span>
0390     
0391     <span class="comment">% rearrange avw.hdr.dime.dim or avw.hdr.dime.pixdim</span>
0392     avw.hdr.dime.dim(2:4) = int16([SliceDim,PixelDim,RowDim]);
0393     avw.hdr.dime.pixdim(2:4) = single([SliceSz,PixelSz,RowSz]);
0394     
0395     
0396     <span class="comment">%--------------------------------------------------------------------------------</span>
0397     <span class="comment">% Orient values 3-5 have the second index reversed in order, essentially</span>
0398     <span class="comment">% 'flipping' the images relative to what would most likely become the vertical</span>
0399     <span class="comment">% axis of the displayed image.</span>
0400     <span class="comment">%--------------------------------------------------------------------------------</span>
0401     
0402   <span class="keyword">case</span> 3, <span class="comment">% transverse/axial flipped</span>
0403     
0404     <span class="comment">% orient = 3:  The primary orientation of the data on disk is in the</span>
0405     <span class="comment">% transverse plane relative to the object scanned.  Most commonly, the fastest</span>
0406     <span class="comment">% moving index through the voxels that are part of this transverse image would</span>
0407     <span class="comment">% span the right-&gt;left extent of the structure imaged, with the next fastest</span>
0408     <span class="comment">% moving index spanning the *anterior-&gt;posterior* extent of the structure.  This</span>
0409     <span class="comment">% 'orient' flag would indicate to Analyze that this data should be placed in</span>
0410     <span class="comment">% the X-Y plane of the 3D Analyze Coordinate System, with the Z dimension</span>
0411     <span class="comment">% being the slice direction.</span>
0412     
0413     <span class="comment">% For the 'transverse flipped' type, the voxels are stored with</span>
0414     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to Left</span>
0415     <span class="comment">% Rows in   'y' axis                  - from patient anterior to Posterior *</span>
0416     <span class="comment">% Slices in 'z' axis                  - from patient inferior to Superior</span>
0417     
0418     fprintf(<span class="string">'...reading axial flipped (+Y from Anterior to Posterior)\n'</span>);
0419     
0420     avw.img = zeros(PixelDim,RowDim,SliceDim);
0421     
0422     n = 1;
0423     x = 1:PixelDim;
0424     <span class="keyword">for</span> z = 1:SliceDim,
0425       <span class="keyword">for</span> y = RowDim:-1:1, <span class="comment">% flip in Y, read A2P file into P2A 3D matrix</span>
0426         
0427         <span class="comment">% load a flipped Y row of X values into Z slice avw.img</span>
0428         avw.img(x,y,z) = tmp(n:n+(PixelDim-1));
0429         n = n + PixelDim;
0430       <span class="keyword">end</span>
0431     <span class="keyword">end</span>
0432     
0433     <span class="comment">% no need to rearrange avw.hdr.dime.dim or avw.hdr.dime.pixdim</span>
0434     
0435     
0436   <span class="keyword">case</span> 4, <span class="comment">% coronal flipped</span>
0437     
0438     <span class="comment">% orient = 4:  The primary orientation of the data on disk is in the coronal</span>
0439     <span class="comment">% plane relative to the object scanned.  Most commonly, the fastest moving</span>
0440     <span class="comment">% index through the voxels that are part of this coronal image would span the</span>
0441     <span class="comment">% right-&gt;left extent of the structure imaged, with the next fastest moving</span>
0442     <span class="comment">% index spanning the *superior-&gt;inferior* extent of the structure.  This 'orient'</span>
0443     <span class="comment">% flag would indicate to Analyze that this data should be placed in the X-Z</span>
0444     <span class="comment">% plane of the 3D Analyze Coordinate System, with the Y dimension being the</span>
0445     <span class="comment">% slice direction.</span>
0446     
0447     <span class="comment">% For the 'coronal flipped' type, the voxels are stored with</span>
0448     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to Left</span>
0449     <span class="comment">% Rows in   'z' axis                  - from patient superior to Inferior*</span>
0450     <span class="comment">% Slices in 'y' axis                  - from patient posterior to Anterior</span>
0451     
0452     fprintf(<span class="string">'...reading coronal flipped (+Z from Superior to Inferior)\n'</span>);
0453     
0454     avw.img = zeros(PixelDim,SliceDim,RowDim);
0455     
0456     n = 1;
0457     x = 1:PixelDim;
0458     <span class="keyword">for</span> y = 1:SliceDim,
0459       <span class="keyword">for</span> z = RowDim:-1:1, <span class="comment">% flip in Z, read S2I file into I2S 3D matrix</span>
0460         
0461         <span class="comment">% load a flipped Z row of X values into Y slice avw.img</span>
0462         avw.img(x,y,z) = tmp(n:n+(PixelDim-1));
0463         n = n + PixelDim;
0464       <span class="keyword">end</span>
0465     <span class="keyword">end</span>
0466     
0467     <span class="comment">% rearrange avw.hdr.dime.dim or avw.hdr.dime.pixdim</span>
0468     avw.hdr.dime.dim(2:4) = int16([PixelDim,SliceDim,RowDim]);
0469     avw.hdr.dime.pixdim(2:4) = single([PixelSz,SliceSz,RowSz]);
0470     
0471     
0472   <span class="keyword">case</span> 5, <span class="comment">% sagittal flipped</span>
0473     
0474     <span class="comment">% orient = 5:  The primary orientation of the data on disk is in the sagittal</span>
0475     <span class="comment">% plane relative to the object scanned.  Most commonly, the fastest moving</span>
0476     <span class="comment">% index through the voxels that are part of this sagittal image would span the</span>
0477     <span class="comment">% posterior-&gt;anterior extent of the structure imaged, with the next fastest</span>
0478     <span class="comment">% moving index spanning the *superior-&gt;inferior* extent of the structure.  This</span>
0479     <span class="comment">% 'orient' flag would indicate to Analyze that this data should be placed in</span>
0480     <span class="comment">% the Y-Z plane of the 3D Analyze Coordinate System, with the X dimension</span>
0481     <span class="comment">% being the slice direction.</span>
0482     
0483     <span class="comment">% For the 'sagittal flipped' type, the voxels are stored with</span>
0484     <span class="comment">% Pixels in 'y' axis (varies fastest) - from patient posterior to Anterior</span>
0485     <span class="comment">% Rows in   'z' axis                  - from patient superior to Inferior*</span>
0486     <span class="comment">% Slices in 'x' axis                  - from patient right to Left</span>
0487     
0488     fprintf(<span class="string">'...reading sagittal flipped (+Z from Superior to Inferior)\n'</span>);
0489     
0490     avw.img = zeros(SliceDim,PixelDim,RowDim);
0491     
0492     n = 1;
0493     y = 1:PixelDim;
0494     
0495     <span class="keyword">for</span> x = 1:SliceDim,
0496       <span class="keyword">for</span> z = RowDim:-1:1, <span class="comment">% flip in Z, read S2I file into I2S 3D matrix</span>
0497         
0498         <span class="comment">% load a flipped Z row of Y values into X slice avw.img</span>
0499         avw.img(x,y,z) = tmp(n:n+(PixelDim-1));
0500         n = n + PixelDim;
0501       <span class="keyword">end</span>
0502     <span class="keyword">end</span>
0503     
0504     <span class="comment">% rearrange avw.hdr.dime.dim or avw.hdr.dime.pixdim</span>
0505     avw.hdr.dime.dim(2:4) = int16([SliceDim,PixelDim,RowDim]);
0506     avw.hdr.dime.pixdim(2:4) = single([SliceSz,PixelSz,RowSz]);
0507     
0508   <span class="keyword">otherwise</span>
0509     
0510     error(<span class="string">'unknown value in avw.hdr.hist.orient, try explicit IMGorient option.'</span>);
0511     
0512 <span class="keyword">end</span>
0513 
0514 t=toc; fprintf(<span class="string">'...done (%5.2f sec).\n\n'</span>,t);
0515 
0516 <span class="keyword">return</span>
0517 
0518 
0519 
0520 
0521 <span class="comment">% This function attempts to read the orientation of the</span>
0522 <span class="comment">% Analyze file according to the hdr.hist.orient field of the</span>
0523 <span class="comment">% header.  Unfortunately, this field is optional and not</span>
0524 <span class="comment">% all programs will set it correctly, so there is no guarantee,</span>
0525 <span class="comment">% that the data loaded will be correctly oriented.  If necessary,</span>
0526 <span class="comment">% experiment with the 'orient' option to read the .img</span>
0527 <span class="comment">% data into the 3D matrix of avw.img as preferred.</span>
0528 <span class="comment">%</span>
0529 
0530 <span class="comment">% (Conventions gathered from e-mail with support@AnalyzeDirect.com)</span>
0531 <span class="comment">%</span>
0532 <span class="comment">% 0  transverse unflipped</span>
0533 <span class="comment">%       X direction first,  progressing from patient right to left,</span>
0534 <span class="comment">%       Y direction second, progressing from patient posterior to anterior,</span>
0535 <span class="comment">%       Z direction third,  progressing from patient inferior to superior.</span>
0536 <span class="comment">% 1  coronal unflipped</span>
0537 <span class="comment">%       X direction first,  progressing from patient right to left,</span>
0538 <span class="comment">%       Z direction second, progressing from patient inferior to superior,</span>
0539 <span class="comment">%       Y direction third,  progressing from patient posterior to anterior.</span>
0540 <span class="comment">% 2  sagittal unflipped</span>
0541 <span class="comment">%       Y direction first,  progressing from patient posterior to anterior,</span>
0542 <span class="comment">%       Z direction second, progressing from patient inferior to superior,</span>
0543 <span class="comment">%       X direction third,  progressing from patient right to left.</span>
0544 <span class="comment">% 3  transverse flipped</span>
0545 <span class="comment">%       X direction first,  progressing from patient right to left,</span>
0546 <span class="comment">%       Y direction second, progressing from patient anterior to posterior,</span>
0547 <span class="comment">%       Z direction third,  progressing from patient inferior to superior.</span>
0548 <span class="comment">% 4  coronal flipped</span>
0549 <span class="comment">%       X direction first,  progressing from patient right to left,</span>
0550 <span class="comment">%       Z direction second, progressing from patient superior to inferior,</span>
0551 <span class="comment">%       Y direction third,  progressing from patient posterior to anterior.</span>
0552 <span class="comment">% 5  sagittal flipped</span>
0553 <span class="comment">%       Y direction first,  progressing from patient posterior to anterior,</span>
0554 <span class="comment">%       Z direction second, progressing from patient superior to inferior,</span>
0555 <span class="comment">%       X direction third,  progressing from patient right to left.</span>
0556 
0557 
0558 <span class="comment">%----------------------------------------------------------------------------</span>
0559 <span class="comment">% From ANALYZE documentation...</span>
0560 <span class="comment">%</span>
0561 <span class="comment">% The ANALYZE coordinate system has an origin in the lower left</span>
0562 <span class="comment">% corner. That is, with the subject lying supine, the coordinate</span>
0563 <span class="comment">% origin is on the right side of the body (x), at the back (y),</span>
0564 <span class="comment">% and at the feet (z). This means that:</span>
0565 <span class="comment">%</span>
0566 <span class="comment">% +X increases from right (R) to left (L)</span>
0567 <span class="comment">% +Y increases from the back (posterior,P) to the front (anterior, A)</span>
0568 <span class="comment">% +Z increases from the feet (inferior,I) to the head (superior, S)</span>
0569 <span class="comment">%</span>
0570 <span class="comment">% The LAS orientation is the radiological convention, where patient</span>
0571 <span class="comment">% left is on the image right.  The alternative neurological</span>
0572 <span class="comment">% convention is RAS (also Talairach convention).</span>
0573 <span class="comment">%</span>
0574 <span class="comment">% A major advantage of the Analzye origin convention is that the</span>
0575 <span class="comment">% coordinate origin of each orthogonal orientation (transverse,</span>
0576 <span class="comment">% coronal, and sagittal) lies in the lower left corner of the</span>
0577 <span class="comment">% slice as it is displayed.</span>
0578 <span class="comment">%</span>
0579 <span class="comment">% Orthogonal slices are numbered from one to the number of slices</span>
0580 <span class="comment">% in that orientation. For example, a volume (x, y, z) dimensioned</span>
0581 <span class="comment">% 128, 256, 48 has:</span>
0582 <span class="comment">%</span>
0583 <span class="comment">%   128 sagittal   slices numbered 1 through 128 (X)</span>
0584 <span class="comment">%   256 coronal    slices numbered 1 through 256 (Y)</span>
0585 <span class="comment">%    48 transverse slices numbered 1 through  48 (Z)</span>
0586 <span class="comment">%</span>
0587 <span class="comment">% Pixel coordinates are made with reference to the slice numbers from</span>
0588 <span class="comment">% which the pixels come. Thus, the first pixel in the volume is</span>
0589 <span class="comment">% referenced p(1,1,1) and not at p(0,0,0).</span>
0590 <span class="comment">%</span>
0591 <span class="comment">% Transverse slices are in the XY plane (also known as axial slices).</span>
0592 <span class="comment">% Sagittal slices are in the ZY plane.</span>
0593 <span class="comment">% Coronal slices are in the ZX plane.</span>
0594 <span class="comment">%</span>
0595 <span class="comment">%----------------------------------------------------------------------------</span>
0596 
0597 
0598 <span class="comment">%----------------------------------------------------------------------------</span>
0599 <span class="comment">% E-mail from support@AnalyzeDirect.com</span>
0600 <span class="comment">%</span>
0601 <span class="comment">% The 'orient' field in the data_history structure specifies the primary</span>
0602 <span class="comment">% orientation of the data as it is stored in the file on disk.  This usually</span>
0603 <span class="comment">% corresponds to the orientation in the plane of acquisition, given that this</span>
0604 <span class="comment">% would correspond to the order in which the data is written to disk by the</span>
0605 <span class="comment">% scanner or other software application.  As you know, this field will contain</span>
0606 <span class="comment">% the values:</span>
0607 <span class="comment">%</span>
0608 <span class="comment">% orient = 0 transverse unflipped</span>
0609 <span class="comment">% 1 coronal unflipped</span>
0610 <span class="comment">% 2 sagittal unflipped</span>
0611 <span class="comment">% 3 transverse flipped</span>
0612 <span class="comment">% 4 coronal flipped</span>
0613 <span class="comment">% 5 sagittal flipped</span>
0614 <span class="comment">%</span>
0615 <span class="comment">% It would be vary rare that you would ever encounter any old Analyze 7.5</span>
0616 <span class="comment">% files that contain values of 'orient' which indicate that the data has been</span>
0617 <span class="comment">% 'flipped'.  The 'flipped flag' values were really only used internal to</span>
0618 <span class="comment">% Analyze to precondition data for fast display in the Movie module, where the</span>
0619 <span class="comment">% images were actually flipped vertically in order to accommodate the raster</span>
0620 <span class="comment">% paint order on older graphics devices.  The only cases you will encounter</span>
0621 <span class="comment">% will have values of 0, 1, or 2.</span>
0622 <span class="comment">%</span>
0623 <span class="comment">% As mentioned, the 'orient' flag only specifies the primary orientation of</span>
0624 <span class="comment">% data as stored in the disk file itself.  It has nothing to do with the</span>
0625 <span class="comment">% representation of the data in the 3D Analyze coordinate system, which always</span>
0626 <span class="comment">% has a fixed representation to the data.  The meaning of the 'orient' values</span>
0627 <span class="comment">% should be interpreted as follows:</span>
0628 <span class="comment">%</span>
0629 <span class="comment">% orient = 0:  The primary orientation of the data on disk is in the</span>
0630 <span class="comment">% transverse plane relative to the object scanned.  Most commonly, the fastest</span>
0631 <span class="comment">% moving index through the voxels that are part of this transverse image would</span>
0632 <span class="comment">% span the right-left extent of the structure imaged, with the next fastest</span>
0633 <span class="comment">% moving index spanning the posterior-anterior extent of the structure.  This</span>
0634 <span class="comment">% 'orient' flag would indicate to Analyze that this data should be placed in</span>
0635 <span class="comment">% the X-Y plane of the 3D Analyze Coordinate System, with the Z dimension</span>
0636 <span class="comment">% being the slice direction.</span>
0637 <span class="comment">%</span>
0638 <span class="comment">% orient = 1:  The primary orientation of the data on disk is in the coronal</span>
0639 <span class="comment">% plane relative to the object scanned.  Most commonly, the fastest moving</span>
0640 <span class="comment">% index through the voxels that are part of this coronal image would span the</span>
0641 <span class="comment">% right-left extent of the structure imaged, with the next fastest moving</span>
0642 <span class="comment">% index spanning the inferior-superior extent of the structure.  This 'orient'</span>
0643 <span class="comment">% flag would indicate to Analyze that this data should be placed in the X-Z</span>
0644 <span class="comment">% plane of the 3D Analyze Coordinate System, with the Y dimension being the</span>
0645 <span class="comment">% slice direction.</span>
0646 <span class="comment">%</span>
0647 <span class="comment">% orient = 2:  The primary orientation of the data on disk is in the sagittal</span>
0648 <span class="comment">% plane relative to the object scanned.  Most commonly, the fastest moving</span>
0649 <span class="comment">% index through the voxels that are part of this sagittal image would span the</span>
0650 <span class="comment">% posterior-anterior extent of the structure imaged, with the next fastest</span>
0651 <span class="comment">% moving index spanning the inferior-superior extent of the structure.  This</span>
0652 <span class="comment">% 'orient' flag would indicate to Analyze that this data should be placed in</span>
0653 <span class="comment">% the Y-Z plane of the 3D Analyze Coordinate System, with the X dimension</span>
0654 <span class="comment">% being the slice direction.</span>
0655 <span class="comment">%</span>
0656 <span class="comment">% Orient values 3-5 have the second index reversed in order, essentially</span>
0657 <span class="comment">% 'flipping' the images relative to what would most likely become the vertical</span>
0658 <span class="comment">% axis of the displayed image.</span>
0659 <span class="comment">%</span>
0660 <span class="comment">% Hopefully you understand the difference between the indication this 'orient'</span>
0661 <span class="comment">% flag has relative to data stored on disk and the full 3D Analyze Coordinate</span>
0662 <span class="comment">% System for data that is managed as a volume image.  As mentioned previously,</span>
0663 <span class="comment">% the orientation of patient anatomy in the 3D Analyze Coordinate System has a</span>
0664 <span class="comment">% fixed orientation relative to each of the orthogonal axes.  This orientation</span>
0665 <span class="comment">% is completely described in the information that is attached, but the basics</span>
0666 <span class="comment">% are:</span>
0667 <span class="comment">%</span>
0668 <span class="comment">% Left-handed coordinate system</span>
0669 <span class="comment">%</span>
0670 <span class="comment">% X-Y plane is Transverse</span>
0671 <span class="comment">% X-Z plane is Coronal</span>
0672 <span class="comment">% Y-Z plane is Sagittal</span>
0673 <span class="comment">%</span>
0674 <span class="comment">% X axis runs from patient right (low X) to patient left (high X)</span>
0675 <span class="comment">% Y axis runs from posterior (low Y) to anterior (high Y)</span>
0676 <span class="comment">% Z axis runs from inferior (low Z) to superior (high Z)</span>
0677 <span class="comment">%</span>
0678 <span class="comment">%----------------------------------------------------------------------------</span>
0679 
0680 
0681 
0682 <span class="comment">%----------------------------------------------------------------------------</span>
0683 <span class="comment">% SPM2 NOTES from spm2 webpage: One thing to watch out for is the image</span>
0684 <span class="comment">% orientation. The proper Analyze format uses a left-handed co-ordinate</span>
0685 <span class="comment">% system, whereas Talairach uses a right-handed one. In SPM99, images were</span>
0686 <span class="comment">% flipped at the spatial normalisation stage (from one co-ordinate system</span>
0687 <span class="comment">% to the other). In SPM2b, a different approach is used, so that either a</span>
0688 <span class="comment">% left- or right-handed co-ordinate system is used throughout. The SPM2b</span>
0689 <span class="comment">% program is told about the handedness that the images are stored with by</span>
0690 <span class="comment">% the spm_flip_analyze_images.m function and the defaults.analyze.flip</span>
0691 <span class="comment">% parameter that is specified in the spm_defaults.m file. These files are</span>
0692 <span class="comment">% intended to be customised for each site. If you previously used SPM99</span>
0693 <span class="comment">% and your images were flipped during spatial normalisation, then set</span>
0694 <span class="comment">% defaults.analyze.flip=1. If no flipping took place, then set</span>
0695 <span class="comment">% defaults.analyze.flip=0. Check that when using the Display facility</span>
0696 <span class="comment">% (possibly after specifying some rigid-body rotations) that:</span>
0697 <span class="comment">%</span>
0698 <span class="comment">% The top-left image is coronal with the top (superior) of the head displayed</span>
0699 <span class="comment">% at the top and the left shown on the left. This is as if the subject is viewed</span>
0700 <span class="comment">% from behind.</span>
0701 <span class="comment">%</span>
0702 <span class="comment">% The bottom-left image is axial with the front (anterior) of the head at the</span>
0703 <span class="comment">% top and the left shown on the left. This is as if the subject is viewed from above.</span>
0704 <span class="comment">%</span>
0705 <span class="comment">% The top-right image is sagittal with the front (anterior) of the head at the</span>
0706 <span class="comment">% left and the top of the head shown at the top. This is as if the subject is</span>
0707 <span class="comment">% viewed from the left.</span>
0708 <span class="comment">%----------------------------------------------------------------------------</span></pre></div>
<hr><address>Generated on Mon 29-Mar-2004 13:14:32 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>