<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of avw_hdr_write</title>
  <meta name="keywords" content="avw_hdr_write">
  <meta name="description" content="AVW_HDR_WRITE - Write Analyze header file (*.hdr)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">mri_toolbox</a> &gt; avw_hdr_write.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for mri_toolbox&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>avw_hdr_write
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>AVW_HDR_WRITE - Write Analyze header file (*.hdr)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function avw_hdr_write(avw, fileprefix, machine) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> AVW_HDR_WRITE - Write Analyze header file (*.hdr)
 
 avw_hdr_write(avw, fileprefix, machine)
 
 eg, avw_hdr_write(avw,'test');
 
 avw        - a struct with .hdr field, which itself is a struct,
              containing all fields of an Analyze header.
              For details, see avw_hdr_read.m
 
 fileprefix - a string, the filename without the .hdr extension.
              If empty, may use avw.fileprefix
 
 machine    - a string, see machineformat in fread for details.
              The default here is 'ieee-le'.
 
 See also, <a href="avw_hdr_read.html" class="code" title="function [ avw, machine ] = avw_hdr_read(fileprefix, machine)">AVW_HDR_READ</a> <a href="avw_hdr_make.html" class="code" title="function [ avw ] = avw_hdr_make">AVW_HDR_MAKE</a>
           <a href="avw_img_read.html" class="code" title="function [ avw, machine ] = avw_img_read(fileprefix,IMGorient,machine)">AVW_IMG_READ</a> <a href="avw_img_write.html" class="code" title="function avw_img_write(avw, fileprefix, IMGorient, machine)">AVW_IMG_WRITE</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="avw_hdr_make.html" class="code" title="function [ avw ] = avw_hdr_make">avw_hdr_make</a>	AVW_HDR_MAKE - Create Analyze format data header (avw.hdr)</li><li><a href="avw_hdr_write.html" class="code" title="function avw_hdr_write(avw, fileprefix, machine)">avw_hdr_write</a>	AVW_HDR_WRITE - Write Analyze header file (*.hdr)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="avw_hdr_write.html" class="code" title="function avw_hdr_write(avw, fileprefix, machine)">avw_hdr_write</a>	AVW_HDR_WRITE - Write Analyze header file (*.hdr)</li><li><a href="avw_img_write.html" class="code" title="function avw_img_write(avw, fileprefix, IMGorient, machine)">avw_img_write</a>	avw_img_write - write Analyze image files (*.img)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function write_header(fid,avw)</a></li><li><a href="#_sub2" class="code">function header_key(fid,hk)</a></li><li><a href="#_sub3" class="code">function image_dimension(fid,dime)</a></li><li><a href="#_sub4" class="code">function data_history(fid,hist)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function avw_hdr_write(avw, fileprefix, machine)</a>
0002 
0003 <span class="comment">% AVW_HDR_WRITE - Write Analyze header file (*.hdr)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% avw_hdr_write(avw, fileprefix, machine)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% eg, avw_hdr_write(avw,'test');</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% avw        - a struct with .hdr field, which itself is a struct,</span>
0010 <span class="comment">%              containing all fields of an Analyze header.</span>
0011 <span class="comment">%              For details, see avw_hdr_read.m</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% fileprefix - a string, the filename without the .hdr extension.</span>
0014 <span class="comment">%              If empty, may use avw.fileprefix</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% machine    - a string, see machineformat in fread for details.</span>
0017 <span class="comment">%              The default here is 'ieee-le'.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% See also, AVW_HDR_READ AVW_HDR_MAKE</span>
0020 <span class="comment">%           AVW_IMG_READ AVW_IMG_WRITE</span>
0021 <span class="comment">%</span>
0022 
0023 <span class="comment">% $Revision: 1.2 $ $Date: 2004/04/08 20:11:24 $</span>
0024 
0025 <span class="comment">% Licence:  GNU GPL, no express or implied warranties</span>
0026 <span class="comment">% History:  05/2002, Darren.Weber@flinders.edu.au</span>
0027 <span class="comment">%           02/2003, Bennett.Landman@ieee.org</span>
0028 <span class="comment">%                    - more specific data history var sizes</span>
0029 <span class="comment">%                    - 02/2003 confirmed, Darren</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%                    The Analyze format and c code below is copyright</span>
0032 <span class="comment">%                    (c) Copyright, 1986-1995</span>
0033 <span class="comment">%                    Biomedical Imaging Resource, Mayo Foundation</span>
0034 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0035 
0036 version = <span class="string">'[$Revision: 1.2 $]'</span>;
0037 fprintf(<span class="string">'AVW_HDR_WRITE [v%s]\n'</span>,version(12:16));  tic;
0038 
0039 <span class="comment">%----------------------------------------------------------------------------</span>
0040 <span class="comment">% Check inputs</span>
0041 
0042 <span class="keyword">if</span> ~exist(<span class="string">'avw'</span>,<span class="string">'var'</span>),
0043     fprintf(<span class="string">'...no input avw - calling avw_hdr_make\n'</span>);
0044     avw = <a href="avw_hdr_make.html" class="code" title="function [ avw ] = avw_hdr_make">avw_hdr_make</a>;
0045 <span class="keyword">elseif</span> isempty(avw),
0046     fprintf(<span class="string">'...empty input avw - calling avw_hdr_make\n'</span>);
0047     avw = <a href="avw_hdr_make.html" class="code" title="function [ avw ] = avw_hdr_make">avw_hdr_make</a>;
0048 <span class="keyword">elseif</span> ~isfield(avw,<span class="string">'hdr'</span>),
0049     fprintf(<span class="string">'...empty input avw.hdr - calling avw_hdr_make\n'</span>);
0050     avw = <a href="avw_hdr_make.html" class="code" title="function [ avw ] = avw_hdr_make">avw_hdr_make</a>;
0051 <span class="keyword">end</span>
0052 <span class="keyword">if</span> ~isequal(avw.hdr.hk.sizeof_hdr,348),
0053     msg = sprintf(<span class="string">'...avw.hdr.hk.sizeof_hdr must be 348!\n'</span>);
0054     error(msg);
0055 <span class="keyword">end</span>
0056 
0057 quit = 0;
0058 <span class="keyword">if</span> ~exist(<span class="string">'fileprefix'</span>,<span class="string">'var'</span>),
0059     <span class="keyword">if</span> isfield(avw,<span class="string">'fileprefix'</span>),
0060         <span class="keyword">if</span> ~isempty(avw.fileprefix),
0061             fileprefix = avw.fileprefix;
0062         <span class="keyword">else</span>,
0063             quit = 1;
0064         <span class="keyword">end</span>
0065     <span class="keyword">else</span>
0066         quit = 1;
0067     <span class="keyword">end</span>
0068     <span class="keyword">if</span> quit,
0069         fprintf(<span class="string">'...no input fileprefix - see help avw_hdr_write\n\n'</span>);
0070         helpwin <a href="avw_hdr_write.html" class="code" title="function avw_hdr_write(avw, fileprefix, machine)">avw_hdr_write</a>;
0071         <span class="keyword">return</span>;
0072     <span class="keyword">end</span>
0073 <span class="keyword">end</span>
0074 
0075 <span class="keyword">if</span> ~exist(<span class="string">'machine'</span>,<span class="string">'var'</span>), machine = <span class="string">'ieee-le'</span>; <span class="keyword">end</span>
0076 
0077 <span class="keyword">if</span> findstr(<span class="string">'.hdr'</span>,fileprefix),
0078 <span class="comment">%    fprintf('AVW_HDR_WRITE: Removing .hdr extension from ''%s''\n',fileprefix);</span>
0079     fileprefix = strrep(fileprefix,<span class="string">'.hdr'</span>,<span class="string">''</span>);
0080 <span class="keyword">end</span>
0081 
0082 
0083 
0084 <span class="comment">%----------------------------------------------------------------------------</span>
0085 <span class="comment">% MAIN</span>
0086 
0087 tic;
0088 
0089 fid = fopen(sprintf(<span class="string">'%s.hdr'</span>,fileprefix),<span class="string">'w'</span>,machine);
0090 <span class="keyword">if</span> fid &lt; 0,
0091     msg = sprintf(<span class="string">'Cannot write to file %s.hdr\n'</span>,fileprefix);
0092     error(msg);
0093 <span class="keyword">else</span>
0094     fprintf(<span class="string">'...writing %s Analyze header.\n'</span>,machine);
0095     <a href="#_sub1" class="code" title="subfunction write_header(fid,avw)">write_header</a>(fid,avw);
0096 <span class="keyword">end</span>
0097 
0098 t=toc; fprintf(<span class="string">'...done (%5.2f sec).\n\n'</span>,t);
0099 
0100 <span class="keyword">return</span>
0101 
0102 
0103 
0104 
0105 
0106 <span class="comment">%----------------------------------------------------------------------------</span>
0107 
0108 <a name="_sub1" href="#_subfunctions" class="code">function write_header(fid,avw)</a>
0109     
0110     <a href="#_sub2" class="code" title="subfunction header_key(fid,hk)">header_key</a>(fid,avw.hdr.hk);
0111     <a href="#_sub3" class="code" title="subfunction image_dimension(fid,dime)">image_dimension</a>(fid,avw.hdr.dime);
0112     <a href="#_sub4" class="code" title="subfunction data_history(fid,hist)">data_history</a>(fid,avw.hdr.hist);
0113     
0114     <span class="comment">% check the file size is 348 bytes</span>
0115     fbytes = ftell(fid);
0116     fclose(fid);
0117     <span class="keyword">if</span> ~isequal(fbytes,348),
0118         msg = sprintf(<span class="string">'...file size is not 348 bytes!\n'</span>);
0119         warning(msg);
0120     <span class="keyword">end</span>
0121     
0122 <span class="keyword">return</span>
0123 
0124 <span class="comment">%----------------------------------------------------------------------------</span>
0125 
0126 <a name="_sub2" href="#_subfunctions" class="code">function header_key(fid,hk)</a>
0127     
0128     <span class="comment">% Original header structures - ANALYZE 7.5</span>
0129     <span class="comment">% struct header_key                      /* header key      */</span>
0130     <span class="comment">%       {                                /* off + size      */</span>
0131     <span class="comment">%       int sizeof_hdr                   /*  0 +  4         */</span>
0132     <span class="comment">%       char data_type[10];              /*  4 + 10         */</span>
0133     <span class="comment">%       char db_name[18];                /* 14 + 18         */</span>
0134     <span class="comment">%       int extents;                     /* 32 +  4         */</span>
0135     <span class="comment">%       short int session_error;         /* 36 +  2         */</span>
0136     <span class="comment">%       char regular;                    /* 38 +  1         */</span>
0137     <span class="comment">%       char hkey_un0;                   /* 39 +  1         */</span>
0138     <span class="comment">%       };                               /* total=40 bytes  */</span>
0139     
0140     fseek(fid,0,<span class="string">'bof'</span>);
0141     
0142     fwrite(fid, hk.sizeof_hdr(1),   <span class="string">'int32'</span>);  <span class="comment">% must be 348!</span>
0143     
0144     data_type = sprintf(<span class="string">'%-10s'</span>,hk.data_type); <span class="comment">% ensure it is 10 chars</span>
0145     fwrite(fid, hk.data_type(1:10), <span class="string">'uchar'</span>);
0146     
0147     db_name   = sprintf(<span class="string">'%-18s'</span>,hk.db_name);   <span class="comment">% ensure it is 18 chars</span>
0148     fwrite(fid, db_name(1:18),      <span class="string">'uchar'</span>);
0149     
0150     fwrite(fid, hk.extents(1),      <span class="string">'int32'</span>);
0151     fwrite(fid, hk.session_error(1),<span class="string">'int16'</span>);
0152     
0153     regular   = sprintf(<span class="string">'%1s'</span>,hk.regular);     <span class="comment">% ensure it is 1 char</span>
0154     fwrite(fid, regular(1),         <span class="string">'uchar'</span>);  <span class="comment">% might be uint8</span>
0155     
0156     <span class="comment">%hkey_un0  = sprintf('%1s',hk.hkey_un0);    % ensure it is 1 char</span>
0157     <span class="comment">%fwrite(fid, hkey_un0(1),        'uchar');</span>
0158     fwrite(fid, hk.hkey_un0(1),     <span class="string">'uint8'</span>);
0159     
0160     <span class="comment">%    &gt;Would you set hkey_un0 as char or uint8?</span>
0161     <span class="comment">%   Really doesn't make any difference.  As far as anyone here can remember,</span>
0162     <span class="comment">%   this was just to pad to an even byte boundary for that structure.  I guess</span>
0163     <span class="comment">%   I'd suggest setting it to a uint8 value of 0 (i.e, truly zero-valued) so</span>
0164     <span class="comment">%   that it doesn't look like anything important!</span>
0165     <span class="comment">%   Denny &lt;hanson.dennis2@mayo.edu&gt;</span>
0166     
0167 <span class="keyword">return</span>
0168 
0169 <span class="comment">%----------------------------------------------------------------------------</span>
0170 
0171 <a name="_sub3" href="#_subfunctions" class="code">function image_dimension(fid,dime)</a>
0172     
0173     <span class="comment">%struct image_dimension</span>
0174     <span class="comment">%       {                                /* off + size      */</span>
0175     <span class="comment">%       short int dim[8];                /* 0 + 16          */</span>
0176     <span class="comment">%       char vox_units[4];               /* 16 + 4          */</span>
0177     <span class="comment">%       char cal_units[8];               /* 20 + 8          */</span>
0178     <span class="comment">%       short int unused1;               /* 28 + 2          */</span>
0179     <span class="comment">%       short int datatype;              /* 30 + 2          */</span>
0180     <span class="comment">%       short int bitpix;                /* 32 + 2          */</span>
0181     <span class="comment">%       short int dim_un0;               /* 34 + 2          */</span>
0182     <span class="comment">%       float pixdim[8];                 /* 36 + 32         */</span>
0183     <span class="comment">%            /*</span>
0184     <span class="comment">%                pixdim[] specifies the voxel dimensions:</span>
0185     <span class="comment">%                pixdim[1] - voxel width</span>
0186     <span class="comment">%                pixdim[2] - voxel height</span>
0187     <span class="comment">%                pixdim[3] - interslice distance</span>
0188     <span class="comment">%                    ..etc</span>
0189     <span class="comment">%            */</span>
0190     <span class="comment">%       float vox_offset;                /* 68 + 4          */</span>
0191     <span class="comment">%       float roi_scale;                 /* 72 + 4          */</span>
0192     <span class="comment">%       float funused1;                  /* 76 + 4          */</span>
0193     <span class="comment">%       float funused2;                  /* 80 + 4          */</span>
0194     <span class="comment">%       float cal_max;                   /* 84 + 4          */</span>
0195     <span class="comment">%       float cal_min;                   /* 88 + 4          */</span>
0196     <span class="comment">%       int compressed;                  /* 92 + 4          */</span>
0197     <span class="comment">%       int verified;                    /* 96 + 4          */</span>
0198     <span class="comment">%       int glmax;                       /* 100 + 4         */</span>
0199     <span class="comment">%       int glmin;                       /* 104 + 4         */</span>
0200     <span class="comment">%       };                               /* total=108 bytes */</span>
0201     
0202     fwrite(fid, dime.dim(1:8),      <span class="string">'int16'</span>);
0203     fwrite(fid, dime.vox_units(1:4),<span class="string">'uchar'</span>);
0204     fwrite(fid, dime.cal_units(1:8),<span class="string">'uchar'</span>);
0205     fwrite(fid, dime.unused1(1),    <span class="string">'int16'</span>);
0206     fwrite(fid, dime.datatype(1),   <span class="string">'int16'</span>);
0207     fwrite(fid, dime.bitpix(1),     <span class="string">'int16'</span>);
0208     fwrite(fid, dime.dim_un0(1),    <span class="string">'int16'</span>);
0209     fwrite(fid, dime.pixdim(1:8),   <span class="string">'float32'</span>);
0210     fwrite(fid, dime.vox_offset(1), <span class="string">'float32'</span>);
0211     
0212     <span class="comment">% Ensure compatibility with SPM (according to MRIcro)</span>
0213     <span class="keyword">if</span> dime.roi_scale == 0, dime.roi_scale = 0.00392157; <span class="keyword">end</span>
0214     fwrite(fid, dime.roi_scale(1),  <span class="string">'float32'</span>);
0215     
0216     fwrite(fid, dime.funused1(1),   <span class="string">'float32'</span>);
0217     fwrite(fid, dime.funused2(1),   <span class="string">'float32'</span>);
0218     fwrite(fid, dime.cal_max(1),    <span class="string">'float32'</span>);
0219     fwrite(fid, dime.cal_min(1),    <span class="string">'float32'</span>);
0220     fwrite(fid, dime.compressed(1), <span class="string">'int32'</span>);
0221     fwrite(fid, dime.verified(1),   <span class="string">'int32'</span>);
0222     fwrite(fid, dime.glmax(1),      <span class="string">'int32'</span>);
0223     fwrite(fid, dime.glmin(1),      <span class="string">'int32'</span>);
0224     
0225 <span class="keyword">return</span>
0226 
0227 <span class="comment">%----------------------------------------------------------------------------</span>
0228 
0229 <a name="_sub4" href="#_subfunctions" class="code">function data_history(fid,hist)</a>
0230     
0231     <span class="comment">% Original header structures - ANALYZE 7.5</span>
0232     <span class="comment">%struct data_history</span>
0233     <span class="comment">%       {                                /* off + size      */</span>
0234     <span class="comment">%       char descrip[80];                /* 0 + 80          */</span>
0235     <span class="comment">%       char aux_file[24];               /* 80 + 24         */</span>
0236     <span class="comment">%       char orient;                     /* 104 + 1         */</span>
0237     <span class="comment">%       char originator[10];             /* 105 + 10        */</span>
0238     <span class="comment">%       char generated[10];              /* 115 + 10        */</span>
0239     <span class="comment">%       char scannum[10];                /* 125 + 10        */</span>
0240     <span class="comment">%       char patient_id[10];             /* 135 + 10        */</span>
0241     <span class="comment">%       char exp_date[10];               /* 145 + 10        */</span>
0242     <span class="comment">%       char exp_time[10];               /* 155 + 10        */</span>
0243     <span class="comment">%       char hist_un0[3];                /* 165 + 3         */</span>
0244     <span class="comment">%       int views                        /* 168 + 4         */</span>
0245     <span class="comment">%       int vols_added;                  /* 172 + 4         */</span>
0246     <span class="comment">%       int start_field;                 /* 176 + 4         */</span>
0247     <span class="comment">%       int field_skip;                  /* 180 + 4         */</span>
0248     <span class="comment">%       int omax;                        /* 184 + 4         */</span>
0249     <span class="comment">%       int omin;                        /* 188 + 4         */</span>
0250     <span class="comment">%       int smax;                        /* 192 + 4         */</span>
0251     <span class="comment">%       int smin;                        /* 196 + 4         */</span>
0252     <span class="comment">%       };                               /* total=200 bytes */</span>
0253     
0254     descrip     = sprintf(<span class="string">'%-80s'</span>, hist.descrip);       <span class="comment">% 80 chars</span>
0255     aux_file    = sprintf(<span class="string">'%-24s'</span>, hist.aux_file);      <span class="comment">% 24 chars</span>
0256     originator  = sprintf(<span class="string">'%-10s'</span>, hist.originator);    <span class="comment">% 10 chars</span>
0257     generated   = sprintf(<span class="string">'%-10s'</span>, hist.generated);     <span class="comment">% 10 chars</span>
0258     scannum     = sprintf(<span class="string">'%-10s'</span>, hist.scannum);       <span class="comment">% 10 chars</span>
0259     patient_id  = sprintf(<span class="string">'%-10s'</span>, hist.patient_id);    <span class="comment">% 10 chars</span>
0260     exp_date    = sprintf(<span class="string">'%-10s'</span>, hist.exp_date);      <span class="comment">% 10 chars</span>
0261     exp_time    = sprintf(<span class="string">'%-10s'</span>, hist.exp_time);      <span class="comment">% 10 chars</span>
0262     hist_un0    = sprintf( <span class="string">'%-3s'</span>, hist.hist_un0);      <span class="comment">%  3 chars</span>
0263     
0264     <span class="comment">% ---</span>
0265     <span class="comment">% The following should not be necessary, but I actually</span>
0266     <span class="comment">% found one instance where it was, so this totally anal</span>
0267     <span class="comment">% retentive approach became necessary, despite the</span>
0268     <span class="comment">% apparently elegant solution above to ensuring that variables</span>
0269     <span class="comment">% are the right length.</span>
0270     
0271     <span class="keyword">if</span> length(descrip) &lt; 80,
0272       paddingN = 80-length(descrip);
0273       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0274       descrip = [descrip,padding];
0275     <span class="keyword">end</span>
0276     <span class="keyword">if</span> length(aux_file) &lt; 24,
0277       paddingN = 24-length(aux_file);
0278       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0279       aux_file = [aux_file,padding];
0280     <span class="keyword">end</span>
0281     <span class="keyword">if</span> length(originator) &lt; 10,
0282       paddingN = 10-length(originator);
0283       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0284       originator = [originator, padding];
0285     <span class="keyword">end</span>
0286     <span class="keyword">if</span> length(generated) &lt; 10,
0287       paddingN = 10-length(generated);
0288       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0289       generated = [generated, padding];
0290     <span class="keyword">end</span>
0291     <span class="keyword">if</span> length(scannum) &lt; 10,
0292       paddingN = 10-length(scannum);
0293       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0294       scannum = [scannum, padding];
0295     <span class="keyword">end</span>
0296     <span class="keyword">if</span> length(patient_id) &lt; 10,
0297       paddingN = 10-length(patient_id);
0298       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0299       patient_id = [patient_id, padding];
0300     <span class="keyword">end</span>
0301     <span class="keyword">if</span> length(exp_date) &lt; 10,
0302       paddingN = 10-length(exp_date);
0303       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0304       exp_date = [exp_date, padding];
0305     <span class="keyword">end</span>
0306     <span class="keyword">if</span> length(exp_time) &lt; 10,
0307       paddingN = 10-length(exp_time);
0308       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0309       exp_time = [exp_time, padding];
0310     <span class="keyword">end</span>
0311     <span class="keyword">if</span> length(hist_un0) &lt; 10,
0312       paddingN = 10-length(hist_un0);
0313       padding = char(repmat(double(<span class="string">' '</span>),1,paddingN));
0314       hist_un0 = [hist_un0, padding];
0315     <span class="keyword">end</span>
0316     
0317     <span class="comment">% -- if you thought that was anal, try this;</span>
0318     <span class="comment">% -- lets check for unusual ASCII char values!</span>
0319     
0320     <span class="keyword">if</span> find(double(descrip)&gt;128),
0321       indexStrangeChar = find(double(descrip)&gt;128);
0322       descrip(indexStrangeChar) = <span class="string">' '</span>;
0323     <span class="keyword">end</span>
0324     <span class="keyword">if</span> find(double(aux_file)&gt;128),
0325       indexStrangeChar = find(double(aux_file)&gt;128);
0326       aux_file(indexStrangeChar) = <span class="string">' '</span>;
0327     <span class="keyword">end</span>
0328     <span class="keyword">if</span> find(double(originator)&gt;128),
0329       indexStrangeChar = find(double(originator)&gt;128);
0330       originator(indexStrangeChar) = <span class="string">' '</span>;
0331     <span class="keyword">end</span>
0332     <span class="keyword">if</span> find(double(generated)&gt;128),
0333       indexStrangeChar = find(double(generated)&gt;128);
0334       generated(indexStrangeChar) = <span class="string">' '</span>;
0335     <span class="keyword">end</span>
0336     <span class="keyword">if</span> find(double(scannum)&gt;128),
0337       indexStrangeChar = find(double(scannum)&gt;128);
0338       scannum(indexStrangeChar) = <span class="string">' '</span>;
0339     <span class="keyword">end</span>
0340     <span class="keyword">if</span> find(double(patient_id)&gt;128),
0341       indexStrangeChar = find(double(patient_id)&gt;128);
0342       patient_id(indexStrangeChar) = <span class="string">' '</span>;
0343     <span class="keyword">end</span>
0344     <span class="keyword">if</span> find(double(exp_date)&gt;128),
0345       indexStrangeChar = find(double(exp_date)&gt;128);
0346       exp_date(indexStrangeChar) = <span class="string">' '</span>;
0347     <span class="keyword">end</span>
0348     <span class="keyword">if</span> find(double(exp_time)&gt;128),
0349       indexStrangeChar = find(double(exp_time)&gt;128);
0350       exp_time(indexStrangeChar) = <span class="string">' '</span>;
0351     <span class="keyword">end</span>
0352     <span class="keyword">if</span> find(double(hist_un0)&gt;128),
0353       indexStrangeChar = find(double(hist_un0)&gt;128);
0354       hist_un0(indexStrangeChar) = <span class="string">' '</span>;
0355     <span class="keyword">end</span>
0356     
0357     
0358     <span class="comment">% --- finally, we write the fields</span>
0359     
0360     fwrite(fid, descrip(1:80),    <span class="string">'uchar'</span>);
0361     fwrite(fid, aux_file(1:24),   <span class="string">'uchar'</span>);
0362     
0363     
0364     <span class="comment">%orient      = sprintf(  '%1s', hist.orient);        %  1 char</span>
0365     <span class="comment">%fwrite(fid, orient(1),        'uchar');</span>
0366     fwrite(fid, hist.orient(1),   <span class="string">'uint8'</span>);     <span class="comment">% see note below on char</span>
0367     
0368     fwrite(fid, originator(1:10), <span class="string">'uchar'</span>);
0369     fwrite(fid, generated(1:10),  <span class="string">'uchar'</span>);
0370     fwrite(fid, scannum(1:10),    <span class="string">'uchar'</span>);
0371     fwrite(fid, patient_id(1:10), <span class="string">'uchar'</span>);
0372     fwrite(fid, exp_date(1:10),   <span class="string">'uchar'</span>);
0373     fwrite(fid, exp_time(1:10),   <span class="string">'uchar'</span>);
0374     fwrite(fid, hist_un0(1:3),    <span class="string">'uchar'</span>);
0375     
0376     fwrite(fid, hist.views(1),      <span class="string">'int32'</span>);
0377     fwrite(fid, hist.vols_added(1), <span class="string">'int32'</span>);
0378     fwrite(fid, hist.start_field(1),<span class="string">'int32'</span>);
0379     fwrite(fid, hist.field_skip(1), <span class="string">'int32'</span>);
0380     fwrite(fid, hist.omax(1),       <span class="string">'int32'</span>);
0381     fwrite(fid, hist.omin(1),       <span class="string">'int32'</span>);
0382     fwrite(fid, hist.smax(1),       <span class="string">'int32'</span>);
0383     fwrite(fid, hist.smin(1),       <span class="string">'int32'</span>);
0384     
0385 <span class="keyword">return</span>
0386 
0387 
0388 
0389 <span class="comment">% Note on using char:</span>
0390 <span class="comment">% The 'char orient' field in the header is intended to</span>
0391 <span class="comment">% hold simply an 8-bit unsigned integer value, not the ASCII representation</span>
0392 <span class="comment">% of the character for that value.  A single 'char' byte is often used to</span>
0393 <span class="comment">% represent an integer value in Analyze if the known value range doesn't</span>
0394 <span class="comment">% go beyond 0-255 - saves a byte over a short int, which may not mean</span>
0395 <span class="comment">% much in today's computing environments, but given that this format</span>
0396 <span class="comment">% has been around since the early 1980's, saving bytes here and there on</span>
0397 <span class="comment">% older systems was important!  In this case, 'char' simply provides the</span>
0398 <span class="comment">% byte of storage - not an indicator of the format for what is stored in</span>
0399 <span class="comment">% this byte.  Generally speaking, anytime a single 'char' is used, it is</span>
0400 <span class="comment">% probably meant to hold an 8-bit integer value, whereas if this has</span>
0401 <span class="comment">% been dimensioned as an array, then it is intended to hold an ASCII</span>
0402 <span class="comment">% character string, even if that was only a single character.</span>
0403 <span class="comment">% Denny  &lt;hanson.dennis2@mayo.edu&gt;</span>
0404 
0405 <span class="comment">% See other notes in avw_hdr_read</span></pre></div>
<hr><address>Generated on Mon 29-Mar-2004 13:14:32 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>