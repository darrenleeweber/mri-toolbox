<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of avw_img_write</title>
  <meta name="keywords" content="avw_img_write">
  <meta name="description" content="avw_img_write - write Analyze image files (*.img)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">mri_toolbox</a> &gt; avw_img_write.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for mri_toolbox&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>avw_img_write
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>avw_img_write - write Analyze image files (*.img)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function avw_img_write(avw, fileprefix, IMGorient, machine) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> avw_img_write - write Analyze image files (*.img)
 
 avw_img_write(avw, fileprefix, [IMGorient], [machine])
 
 avw.img    - a 3D matrix of image data (double precision).
 avw.hdr    - a struct with image data parameters.  If
              not empty, this function calls avw_hdr_write.
 
 fileprefix - a string, the filename without the .img
              extension. If empty, may use avw.fileprefix
 
 IMGorient - optional int, force writing of specified 
             orientation, with values:
 
   [],  if empty, will use avw.hdr.hist.orient field
    0,  transverse/axial unflipped (default, radiological)
    1,  coronal unflipped
    2,  sagittal unflipped
    3,  transverse/axial flipped, left to right
    4,  coronal flipped, anterior to posterior
    5,  sagittal flipped, superior to inferior
 
 This function will set avw.hdr.hist.orient and write the 
 image data in a corresponding order.  This function is 
 in alpha development, so it has not been exhaustively 
 tested (07/2003). See avw_img_read for more information 
 and documentation on the orientation option.  
 Orientations 3-5 are NOT recommended!  They are part 
 of the Analyze format, but only used in Analyze
 for faster raster graphics during movies.
 
 machine - a string, see machineformat in fread for details.
           The default here is 'ieee-le'.
 
 Tip: to change the data type, set avw.hdr.dime.datatype to:
 
     1    Binary             (  1 bit  per voxel)
     2    Unsigned character (  8 bits per voxel)
     4    Signed short       ( 16 bits per voxel)
     8    Signed integer     ( 32 bits per voxel)
    16    Floating point     ( 32 bits per voxel)
    32    Complex, 2 floats  ( 64 bits per voxel), not supported
    64    Double precision   ( 64 bits per voxel)
   128    Red-Green-Blue     (128 bits per voxel), not supported
 
 See also: <a href="avw_write.html" class="code" title="function avw_write(avw, fileprefix, IMGorient, machine)">avw_write</a>, <a href="avw_hdr_write.html" class="code" title="function avw_hdr_write(avw, fileprefix, machine)">avw_hdr_write</a>,
           <a href="avw_read.html" class="code" title="function [ avw, machine ] = avw_read(fileprefix,IMGorient,machine)">avw_read</a>, <a href="avw_hdr_read.html" class="code" title="function [ avw, machine ] = avw_hdr_read(fileprefix, machine)">avw_hdr_read</a>, <a href="avw_img_read.html" class="code" title="function [ avw, machine ] = avw_img_read(fileprefix,IMGorient,machine)">avw_img_read</a>, <a href="avw_view.html" class="code" title="function [ varargout ] = avw_view(avw,parent,command),">avw_view</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="avw_hdr_write.html" class="code" title="function avw_hdr_write(avw, fileprefix, machine)">avw_hdr_write</a>	AVW_HDR_WRITE - Write Analyze header file (*.hdr)</li><li><a href="avw_img_write.html" class="code" title="function avw_img_write(avw, fileprefix, IMGorient, machine)">avw_img_write</a>	avw_img_write - write Analyze image files (*.img)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="avw_converter_script.html" class="code" title="">avw_converter_script</a>	avw_converter_script - convert byte order of .img files</li><li><a href="avw_img_write.html" class="code" title="function avw_img_write(avw, fileprefix, IMGorient, machine)">avw_img_write</a>	avw_img_write - write Analyze image files (*.img)</li><li><a href="avw_write.html" class="code" title="function avw_write(avw, fileprefix, IMGorient, machine)">avw_write</a>	avw_write - write Analyze files (*.img & *.hdr)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function avw = write_image(fid,avw,fileprefix,IMGorient,machine)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function avw_img_write(avw, fileprefix, IMGorient, machine)</a>
0002 
0003 <span class="comment">% avw_img_write - write Analyze image files (*.img)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% avw_img_write(avw, fileprefix, [IMGorient], [machine])</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% avw.img    - a 3D matrix of image data (double precision).</span>
0008 <span class="comment">% avw.hdr    - a struct with image data parameters.  If</span>
0009 <span class="comment">%              not empty, this function calls avw_hdr_write.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% fileprefix - a string, the filename without the .img</span>
0012 <span class="comment">%              extension. If empty, may use avw.fileprefix</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% IMGorient - optional int, force writing of specified</span>
0015 <span class="comment">%             orientation, with values:</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%   [],  if empty, will use avw.hdr.hist.orient field</span>
0018 <span class="comment">%    0,  transverse/axial unflipped (default, radiological)</span>
0019 <span class="comment">%    1,  coronal unflipped</span>
0020 <span class="comment">%    2,  sagittal unflipped</span>
0021 <span class="comment">%    3,  transverse/axial flipped, left to right</span>
0022 <span class="comment">%    4,  coronal flipped, anterior to posterior</span>
0023 <span class="comment">%    5,  sagittal flipped, superior to inferior</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% This function will set avw.hdr.hist.orient and write the</span>
0026 <span class="comment">% image data in a corresponding order.  This function is</span>
0027 <span class="comment">% in alpha development, so it has not been exhaustively</span>
0028 <span class="comment">% tested (07/2003). See avw_img_read for more information</span>
0029 <span class="comment">% and documentation on the orientation option.</span>
0030 <span class="comment">% Orientations 3-5 are NOT recommended!  They are part</span>
0031 <span class="comment">% of the Analyze format, but only used in Analyze</span>
0032 <span class="comment">% for faster raster graphics during movies.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% machine - a string, see machineformat in fread for details.</span>
0035 <span class="comment">%           The default here is 'ieee-le'.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% Tip: to change the data type, set avw.hdr.dime.datatype to:</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%     1    Binary             (  1 bit  per voxel)</span>
0040 <span class="comment">%     2    Unsigned character (  8 bits per voxel)</span>
0041 <span class="comment">%     4    Signed short       ( 16 bits per voxel)</span>
0042 <span class="comment">%     8    Signed integer     ( 32 bits per voxel)</span>
0043 <span class="comment">%    16    Floating point     ( 32 bits per voxel)</span>
0044 <span class="comment">%    32    Complex, 2 floats  ( 64 bits per voxel), not supported</span>
0045 <span class="comment">%    64    Double precision   ( 64 bits per voxel)</span>
0046 <span class="comment">%   128    Red-Green-Blue     (128 bits per voxel), not supported</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% See also: avw_write, avw_hdr_write,</span>
0049 <span class="comment">%           avw_read, avw_hdr_read, avw_img_read, avw_view</span>
0050 <span class="comment">%</span>
0051 
0052 <span class="comment">% $Revision: 1.2 $ $Date: 2004/04/08 20:11:24 $</span>
0053 
0054 <span class="comment">% Licence:  GNU GPL, no express or implied warranties</span>
0055 <span class="comment">% History:  05/2002, Darren.Weber@flinders.edu.au</span>
0056 <span class="comment">%                    The Analyze format is copyright</span>
0057 <span class="comment">%                    (c) Copyright, 1986-1995</span>
0058 <span class="comment">%                    Biomedical Imaging Resource, Mayo Foundation</span>
0059 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0060 
0061 
0062 <span class="comment">%------------------------------------------------------------------------</span>
0063 <span class="comment">% Check inputs</span>
0064 
0065 <span class="keyword">if</span> ~exist(<span class="string">'avw'</span>,<span class="string">'var'</span>),
0066     doc <a href="avw_img_write.html" class="code" title="function avw_img_write(avw, fileprefix, IMGorient, machine)">avw_img_write</a>;
0067     msg = sprintf(<span class="string">'\n...no input avw.\n'</span>);
0068     error(msg);
0069 <span class="keyword">elseif</span> isempty(avw),
0070     msg = sprintf(<span class="string">'\n...empty input avw.\n'</span>);
0071     error(msg);
0072 <span class="keyword">elseif</span> ~isfield(avw,<span class="string">'img'</span>),
0073     msg = sprintf(<span class="string">'\n...empty input avw.img\n'</span>);
0074     error(msg);
0075 <span class="keyword">end</span>
0076 
0077 <span class="keyword">if</span> ~exist(<span class="string">'fileprefix'</span>,<span class="string">'var'</span>),
0078     <span class="keyword">if</span> isfield(avw,<span class="string">'fileprefix'</span>),
0079         <span class="keyword">if</span> ~isempty(avw.fileprefix),
0080             fileprefix = avw.fileprefix;
0081         <span class="keyword">else</span>
0082             fileprefix = <span class="string">''</span>;
0083         <span class="keyword">end</span>
0084     <span class="keyword">end</span>
0085 <span class="keyword">end</span>
0086 <span class="keyword">if</span> isempty(fileprefix),
0087     doc <a href="avw_img_write.html" class="code" title="function avw_img_write(avw, fileprefix, IMGorient, machine)">avw_img_write</a>;
0088     fprintf(<span class="string">'\n...no input fileprefix - see help avw_img_write\n'</span>);
0089     <span class="keyword">return</span>;
0090 <span class="keyword">end</span>
0091 
0092 <span class="keyword">if</span> ~exist(<span class="string">'IMGorient'</span>,<span class="string">'var'</span>), IMGorient = <span class="string">''</span>; <span class="keyword">end</span>
0093 <span class="keyword">if</span> ~exist(<span class="string">'machine'</span>,<span class="string">'var'</span>), machine = <span class="string">'ieee-le'</span>; <span class="keyword">end</span>
0094 
0095 <span class="keyword">if</span> findstr(<span class="string">'.hdr'</span>,fileprefix),
0096 <span class="comment">%    fprintf('AVW_IMG_WRITE: Removing .hdr extension from ''%s''\n',fileprefix);</span>
0097     fileprefix = strrep(fileprefix,<span class="string">'.hdr'</span>,<span class="string">''</span>);
0098 <span class="keyword">end</span>
0099 <span class="keyword">if</span> findstr(<span class="string">'.img'</span>,fileprefix),
0100 <span class="comment">%    fprintf('AVW_IMG_WRITE: Removing .img extension from ''%s''\n',fileprefix);</span>
0101     fileprefix = strrep(fileprefix,<span class="string">'.img'</span>,<span class="string">''</span>);
0102 <span class="keyword">end</span>
0103 
0104 
0105 
0106 <span class="comment">%------------------------------------------------------------------------</span>
0107 <span class="comment">% MAIN</span>
0108 
0109 version = <span class="string">'[$Revision: 1.2 $]'</span>;
0110 fprintf(<span class="string">'\nAVW_IMG_WRITE [v%s]\n'</span>,version(12:16));  tic;
0111 
0112 fid = fopen(sprintf(<span class="string">'%s.img'</span>,fileprefix),<span class="string">'w'</span>,machine);
0113 <span class="keyword">if</span> fid &lt; 0,
0114     msg = sprintf(<span class="string">'Cannot open file %s.img\n'</span>,fileprefix);
0115     error(msg);
0116 <span class="keyword">else</span>
0117     avw = <a href="#_sub1" class="code" title="subfunction avw = write_image(fid,avw,fileprefix,IMGorient,machine)">write_image</a>(fid,avw,fileprefix,IMGorient,machine);
0118 <span class="keyword">end</span>
0119 
0120 t=toc; fprintf(<span class="string">'...done (%5.2f sec).\n\n'</span>,t);
0121 
0122 <span class="comment">% MUST write header after the image, to ensure any</span>
0123 <span class="comment">% orientation changes during image write are saved</span>
0124 <span class="comment">% in the header</span>
0125 <a href="avw_hdr_write.html" class="code" title="function avw_hdr_write(avw, fileprefix, machine)">avw_hdr_write</a>(avw,fileprefix,machine);
0126 
0127 <span class="keyword">return</span>
0128 
0129 
0130 
0131 
0132 <span class="comment">%-----------------------------------------------------------------------------------</span>
0133 
0134 <a name="_sub1" href="#_subfunctions" class="code">function avw = write_image(fid,avw,fileprefix,IMGorient,machine)</a>
0135 
0136 <span class="comment">% short int bitpix;    /* Number of bits per pixel; 1, 8, 16, 32, or 64. */</span>
0137 <span class="comment">% short int datatype   /* Datatype for this image set */</span>
0138 <span class="comment">% /*Acceptable values for datatype are*/</span>
0139 <span class="comment">% #define DT_NONE             0</span>
0140 <span class="comment">% #define DT_UNKNOWN          0    /*Unknown data type*/</span>
0141 <span class="comment">% #define DT_BINARY           1    /*Binary             ( 1 bit per voxel)*/</span>
0142 <span class="comment">% #define DT_UNSIGNED_CHAR    2    /*Unsigned character ( 8 bits per voxel)*/</span>
0143 <span class="comment">% #define DT_SIGNED_SHORT     4    /*Signed short       (16 bits per voxel)*/</span>
0144 <span class="comment">% #define DT_SIGNED_INT       8    /*Signed integer     (32 bits per voxel)*/</span>
0145 <span class="comment">% #define DT_FLOAT           16    /*Floating point     (32 bits per voxel)*/</span>
0146 <span class="comment">% #define DT_COMPLEX         32    /*Complex,2 floats   (64 bits per voxel)/*</span>
0147 <span class="comment">% #define DT_DOUBLE          64    /*Double precision   (64 bits per voxel)*/</span>
0148 <span class="comment">% #define DT_RGB            128    /*A Red-Green-Blue datatype*/</span>
0149 <span class="comment">% #define DT_ALL            255    /*Undocumented*/</span>
0150 
0151 <span class="keyword">switch</span> double(avw.hdr.dime.datatype),
0152 <span class="keyword">case</span>   1,
0153     avw.hdr.dime.bitpix = int16( 1); precision = <span class="string">'bit1'</span>;
0154 <span class="keyword">case</span>   2,
0155     avw.hdr.dime.bitpix = int16( 8); precision = <span class="string">'uchar'</span>;
0156 <span class="keyword">case</span>   4,
0157     avw.hdr.dime.bitpix = int16(16); precision = <span class="string">'int16'</span>;
0158 <span class="keyword">case</span>   8,
0159     avw.hdr.dime.bitpix = int16(32); precision = <span class="string">'int32'</span>;
0160 <span class="keyword">case</span>  16,
0161     avw.hdr.dime.bitpix = int16(32); precision = <span class="string">'single'</span>;
0162 <span class="keyword">case</span>  32,
0163     error(<span class="string">'...complex datatype not yet supported.\n'</span>);
0164 <span class="keyword">case</span>  64,
0165     avw.hdr.dime.bitpix = int16(64); precision = <span class="string">'double'</span>;
0166 <span class="keyword">case</span> 128,
0167     error(<span class="string">'...RGB datatype not yet supported.\n'</span>);
0168 <span class="keyword">otherwise</span>
0169     fprintf(<span class="string">'...unknown datatype, using type 16 (32 bit floats).\n'</span>);
0170     avw.hdr.dime.datatype = int16(16);
0171     avw.hdr.dime.bitpix = int16(32); precision = <span class="string">'single'</span>;
0172 <span class="keyword">end</span>
0173 
0174 
0175 <span class="comment">% write the .img file, depending on the .img orientation</span>
0176 fprintf(<span class="string">'...writing %s precision Analyze image (%s).\n'</span>,precision,machine);
0177 
0178 fseek(fid,0,<span class="string">'bof'</span>);
0179 
0180 <span class="comment">% The standard image orientation is axial unflipped</span>
0181 <span class="keyword">if</span> isempty(avw.hdr.hist.orient),
0182     msg = [ <span class="string">'...WARNING: avw.hdr.hist.orient ~= 0.\n'</span>,<span class="keyword">...</span>
0183             <span class="string">'   This function assumes the input avw.img is\n'</span>,<span class="keyword">...</span>
0184             <span class="string">'   in axial unflipped orientation in memory.  This is\n'</span>,<span class="keyword">...</span>
0185             <span class="string">'   created by the avw_img_read function, which converts\n'</span>,<span class="keyword">...</span>
0186             <span class="string">'   any input file image to axial unflipped in memory.\n'</span>];
0187     fprintf(msg)
0188 <span class="keyword">end</span>
0189 
0190 <span class="keyword">if</span> isempty(IMGorient),
0191     fprintf(<span class="string">'...no IMGorient specified, using avw.hdr.hist.orient value.\n'</span>);
0192     IMGorient = double(avw.hdr.hist.orient);
0193 <span class="keyword">end</span>
0194 
0195 <span class="keyword">if</span> ~isfinite(IMGorient),
0196     fprintf(<span class="string">'...IMGorient is not finite!\n'</span>);
0197     IMGorient = 99;
0198 <span class="keyword">end</span>
0199 
0200 <span class="keyword">switch</span> IMGorient,
0201     
0202 <span class="keyword">case</span> 0, <span class="comment">% transverse/axial unflipped</span>
0203     
0204     <span class="comment">% For the 'transverse unflipped' type, the voxels are stored with</span>
0205     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to left</span>
0206     <span class="comment">% Rows in   'y' axis                  - from patient posterior to anterior</span>
0207     <span class="comment">% Slices in 'z' axis                  - from patient inferior to superior</span>
0208     
0209     fprintf(<span class="string">'...writing axial unflipped\n'</span>);
0210     
0211     avw.hdr.hist.orient = uint8(0);
0212     
0213     SliceDim = double(avw.hdr.dime.dim(4)); <span class="comment">% z</span>
0214     RowDim   = double(avw.hdr.dime.dim(3)); <span class="comment">% y</span>
0215     PixelDim = double(avw.hdr.dime.dim(2)); <span class="comment">% x</span>
0216     SliceSz  = double(avw.hdr.dime.pixdim(4));
0217     RowSz    = double(avw.hdr.dime.pixdim(3));
0218     PixelSz  = double(avw.hdr.dime.pixdim(2));
0219     
0220     x = 1:PixelDim;
0221     <span class="keyword">for</span> z = 1:SliceDim,
0222         <span class="keyword">for</span> y = 1:RowDim,
0223             fwrite(fid,avw.img(x,y,z),precision);
0224         <span class="keyword">end</span>
0225     <span class="keyword">end</span>
0226     
0227 <span class="keyword">case</span> 1, <span class="comment">% coronal unflipped</span>
0228     
0229     <span class="comment">% For the 'coronal unflipped' type, the voxels are stored with</span>
0230     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to left</span>
0231     <span class="comment">% Rows in   'z' axis                  - from patient inferior to superior</span>
0232     <span class="comment">% Slices in 'y' axis                  - from patient posterior to anterior</span>
0233     
0234     fprintf(<span class="string">'...writing coronal unflipped\n'</span>);
0235     
0236     avw.hdr.hist.orient = uint8(1);
0237     
0238     SliceDim = double(avw.hdr.dime.dim(3)); <span class="comment">% y</span>
0239     RowDim   = double(avw.hdr.dime.dim(4)); <span class="comment">% z</span>
0240     PixelDim = double(avw.hdr.dime.dim(2)); <span class="comment">% x</span>
0241     SliceSz  = double(avw.hdr.dime.pixdim(3));
0242     RowSz    = double(avw.hdr.dime.pixdim(4));
0243     PixelSz  = double(avw.hdr.dime.pixdim(2));
0244     
0245     x = 1:PixelDim;
0246     <span class="keyword">for</span> y = 1:SliceDim,
0247         <span class="keyword">for</span> z = 1:RowDim,
0248             fwrite(fid,avw.img(x,y,z),precision);
0249         <span class="keyword">end</span>
0250     <span class="keyword">end</span>
0251     
0252 <span class="keyword">case</span> 2, <span class="comment">% sagittal unflipped</span>
0253     
0254     <span class="comment">% For the 'sagittal unflipped' type, the voxels are stored with</span>
0255     <span class="comment">% Pixels in 'y' axis (varies fastest) - from patient posterior to anterior</span>
0256     <span class="comment">% Rows in   'z' axis                  - from patient inferior to superior</span>
0257     <span class="comment">% Slices in 'x' axis                  - from patient right to left</span>
0258     
0259     fprintf(<span class="string">'...writing sagittal unflipped\n'</span>);
0260     
0261     avw.hdr.hist.orient = uint8(2);
0262     
0263     SliceDim = double(avw.hdr.dime.dim(2)); <span class="comment">% x</span>
0264     RowDim   = double(avw.hdr.dime.dim(4)); <span class="comment">% z</span>
0265     PixelDim = double(avw.hdr.dime.dim(3)); <span class="comment">% y</span>
0266     SliceSz  = double(avw.hdr.dime.pixdim(2));
0267     RowSz    = double(avw.hdr.dime.pixdim(4));
0268     PixelSz  = double(avw.hdr.dime.pixdim(3));
0269     
0270     y = 1:PixelDim;
0271     <span class="keyword">for</span> x = 1:SliceDim,
0272         <span class="keyword">for</span> z = 1:RowDim,
0273             fwrite(fid,avw.img(x,y,z),precision);
0274         <span class="keyword">end</span>
0275     <span class="keyword">end</span>
0276     
0277 <span class="keyword">case</span> 3, <span class="comment">% transverse/axial flipped</span>
0278     
0279     <span class="comment">% For the 'transverse flipped' type, the voxels are stored with</span>
0280     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to left</span>
0281     <span class="comment">% Rows in   'y' axis                  - from patient anterior to posterior*</span>
0282     <span class="comment">% Slices in 'z' axis                  - from patient inferior to superior</span>
0283     
0284     fprintf(<span class="string">'...writing axial flipped (+Y from Anterior to Posterior)\n'</span>);
0285     
0286     avw.hdr.hist.orient = uint8(3);
0287     
0288     SliceDim = double(avw.hdr.dime.dim(4)); <span class="comment">% z</span>
0289     RowDim   = double(avw.hdr.dime.dim(3)); <span class="comment">% y</span>
0290     PixelDim = double(avw.hdr.dime.dim(2)); <span class="comment">% x</span>
0291     SliceSz  = double(avw.hdr.dime.pixdim(4));
0292     RowSz    = double(avw.hdr.dime.pixdim(3));
0293     PixelSz  = double(avw.hdr.dime.pixdim(2));
0294     
0295     x = 1:PixelDim;
0296     <span class="keyword">for</span> z = 1:SliceDim,
0297         <span class="keyword">for</span> y = RowDim:-1:1, <span class="comment">% flipped in Y</span>
0298             fwrite(fid,avw.img(x,y,z),precision);
0299         <span class="keyword">end</span>
0300     <span class="keyword">end</span>
0301     
0302 <span class="keyword">case</span> 4, <span class="comment">% coronal flipped</span>
0303     
0304     <span class="comment">% For the 'coronal flipped' type, the voxels are stored with</span>
0305     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to left</span>
0306     <span class="comment">% Rows in   'z' axis                  - from patient inferior to superior</span>
0307     <span class="comment">% Slices in 'y' axis                  - from patient anterior to posterior</span>
0308     
0309     fprintf(<span class="string">'...writing coronal flipped (+Z from Superior to Inferior)\n'</span>);
0310     
0311     avw.hdr.hist.orient = uint8(4);
0312     
0313     SliceDim = double(avw.hdr.dime.dim(3)); <span class="comment">% y</span>
0314     RowDim   = double(avw.hdr.dime.dim(4)); <span class="comment">% z</span>
0315     PixelDim = double(avw.hdr.dime.dim(2)); <span class="comment">% x</span>
0316     SliceSz  = double(avw.hdr.dime.pixdim(3));
0317     RowSz    = double(avw.hdr.dime.pixdim(4));
0318     PixelSz  = double(avw.hdr.dime.pixdim(2));
0319     
0320     x = 1:PixelDim;
0321     <span class="keyword">for</span> y = 1:SliceDim,
0322         <span class="keyword">for</span> z = RowDim:-1:1,
0323             fwrite(fid,avw.img(x,y,z),precision);
0324         <span class="keyword">end</span>
0325     <span class="keyword">end</span>
0326     
0327 <span class="keyword">case</span> 5, <span class="comment">% sagittal flipped</span>
0328     
0329     <span class="comment">% For the 'sagittal flipped' type, the voxels are stored with</span>
0330     <span class="comment">% Pixels in 'y' axis (varies fastest) - from patient posterior to anterior</span>
0331     <span class="comment">% Rows in   'z' axis                  - from patient superior to inferior</span>
0332     <span class="comment">% Slices in 'x' axis                  - from patient right to left</span>
0333     
0334     fprintf(<span class="string">'...writing sagittal flipped (+Z from Superior to Inferior)\n'</span>);
0335     
0336     avw.hdr.hist.orient = uint8(5);
0337     
0338     SliceDim = double(avw.hdr.dime.dim(2)); <span class="comment">% x</span>
0339     RowDim   = double(avw.hdr.dime.dim(4)); <span class="comment">% z</span>
0340     PixelDim = double(avw.hdr.dime.dim(3)); <span class="comment">% y</span>
0341     SliceSz  = double(avw.hdr.dime.pixdim(2));
0342     RowSz    = double(avw.hdr.dime.pixdim(4));
0343     PixelSz  = double(avw.hdr.dime.pixdim(3));
0344     
0345     y = 1:PixelDim;
0346     <span class="keyword">for</span> x = 1:SliceDim,
0347         <span class="keyword">for</span> z = RowDim:-1:1, <span class="comment">% superior to inferior</span>
0348             fwrite(fid,avw.img(x,y,z),precision);
0349         <span class="keyword">end</span>
0350     <span class="keyword">end</span>
0351     
0352 <span class="keyword">otherwise</span>, <span class="comment">% transverse/axial unflipped</span>
0353     
0354     <span class="comment">% For the 'transverse unflipped' type, the voxels are stored with</span>
0355     <span class="comment">% Pixels in 'x' axis (varies fastest) - from patient right to left</span>
0356     <span class="comment">% Rows in   'y' axis                  - from patient posterior to anterior</span>
0357     <span class="comment">% Slices in 'z' axis                  - from patient inferior to superior</span>
0358     
0359     fprintf(<span class="string">'...unknown orientation specified, assuming default axial unflipped\n'</span>);
0360     
0361     avw.hdr.hist.orient = uint8(0);
0362     
0363     SliceDim = double(avw.hdr.dime.dim(4)); <span class="comment">% z</span>
0364     RowDim   = double(avw.hdr.dime.dim(3)); <span class="comment">% y</span>
0365     PixelDim = double(avw.hdr.dime.dim(2)); <span class="comment">% x</span>
0366     SliceSz  = double(avw.hdr.dime.pixdim(4));
0367     RowSz    = double(avw.hdr.dime.pixdim(3));
0368     PixelSz  = double(avw.hdr.dime.pixdim(2));
0369     
0370     x = 1:PixelDim;
0371     <span class="keyword">for</span> z = 1:SliceDim,
0372         <span class="keyword">for</span> y = 1:RowDim,
0373             fwrite(fid,avw.img(x,y,z),precision);
0374         <span class="keyword">end</span>
0375     <span class="keyword">end</span>
0376     
0377 <span class="keyword">end</span>
0378 
0379 fclose(fid);
0380 
0381 <span class="comment">% Update the header</span>
0382 avw.hdr.dime.dim(2:4) = int16([PixelDim,RowDim,SliceDim]);
0383 avw.hdr.dime.pixdim(2:4) = single([PixelSz,RowSz,SliceSz]);
0384 
0385 <span class="keyword">return</span></pre></div>
<hr><address>Generated on Mon 29-Mar-2004 13:14:32 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>